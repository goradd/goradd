// Code generated by GoRADD. DO NOT EDIT.

package model

import (
	//"log"
	//"github.com/goradd/goradd/pkg/orm/query"
	"strconv"
)

const (
	PersonTypeContractor    PersonType = 1
	PersonTypeManager       PersonType = 2
	PersonTypeInactive      PersonType = 3
	PersonTypeCompanyCar    PersonType = 4
	PersonTypeWorksFromHome PersonType = 5
)

// PersonTypeMaxValue is the maximum enumerated value of PersonType
// doc: type=PersonType
const PersonTypeMaxValue = 5

type PersonType int

// String returns the name value of the type and satisfies the fmt.Stringer interface
func (p PersonType) String() string {
	switch p {
	case 0:
		return ""
	case 1:
		return "Contractor"
	case 2:
		return "Manager"
	case 3:
		return "Inactive"
	case 4:
		return "Company Car"
	case 5:
		return "Works From Home"
	default:
		panic("index out of range")
	}
	return "" // prevent warning
}

// ID returns a string representation of the id and satisfies the IDer interface
func (p PersonType) ID() string {
	return strconv.Itoa(int(p))
}

// PersonTypeFromID converts a PersonType ID to a PersonType
func PersonTypeFromID(id string) PersonType {
	switch id {
	case "1":
		return PersonType(1)
	case "2":
		return PersonType(2)
	case "3":
		return PersonType(3)
	case "4":
		return PersonType(4)
	case "5":
		return PersonType(5)
	}
	return PersonType(0)
}

// PersonTypesFromIDs converts a slice of PersonType IDs to a slice of PersonType
func PersonTypesFromIDs(ids []string) (values []PersonType) {
	values = make([]PersonType, 0, len(ids))
	for _, id := range ids {
		values = append(values, PersonTypeFromID(id))
	}
	return
}

// PersonTypeFromName converts a PersonType name to a PersonType
func PersonTypeFromName(name string) PersonType {
	switch name {
	case "Contractor":
		return PersonType(1)
	case "Manager":
		return PersonType(2)
	case "Inactive":
		return PersonType(3)
	case "Company Car":
		return PersonType(4)
	case "Works From Home":
		return PersonType(5)
	}
	return PersonType(0)
}

// AllPersonTypes returns a slice of all the PersonType values.
func AllPersonTypes() (values []PersonType) {
	values = append(values, 1)
	values = append(values, 2)
	values = append(values, 3)
	values = append(values, 4)
	values = append(values, 5)
	return
}

// AllPersonTypesI returns a slice of all the PersonType values as generic interfaces.
// doc: type=PersonType
func AllPersonTypesI() (values []any) {
	values = make([]interface{}, 5, 5)
	values[0] = PersonType(1)
	values[1] = PersonType(2)
	values[2] = PersonType(3)
	values[3] = PersonType(4)
	values[4] = PersonType(5)
	return
}

// Label returns the string that will be displayed to a user for this item. Together with
// the Value function, it satisfies the ItemLister interface that makes it easy
// to create a dropdown list of items.
func (p PersonType) Label() string {
	return p.String()
}

// Value returns the value that will be used in dropdown lists and satisfies the
// Valuer and ItemLister interfaces.
func (p PersonType) Value() interface{} {
	return p.ID()
}

func (p PersonType) Name() string {
	switch p {
	case 0:
		return ""
	case 1:
		return "Contractor"
	case 2:
		return "Manager"
	case 3:
		return "Inactive"
	case 4:
		return "Company Car"
	case 5:
		return "Works From Home"
	default:
		panic("Index out of range")
	}
	return "" // prevent warning
}

// PersonTypeNames returns a slice of all the Names associated with PersonType values.
// doc: type=PersonType
func PersonTypeNames() []string {
	return []string{
		// 0 item will be a blank
		"",
		"Contractor",
		"Manager",
		"Inactive",
		"Company Car",
		"Works From Home",
	}
}

func (p PersonType) Get(key string) interface{} {

	switch key {
	case "Name":
		return p.Name()
	default:
		return nil
	}
}
