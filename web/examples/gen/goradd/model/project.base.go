// Code generated by GoRADD. DO NOT EDIT.

package model

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"time"

	"github.com/goradd/goradd/pkg/orm/broadcast"
	"github.com/goradd/goradd/pkg/orm/db"
	"github.com/goradd/goradd/pkg/orm/op"
	. "github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/pkg/orm/query"
	"github.com/goradd/goradd/pkg/stringmap"
	time2 "github.com/goradd/goradd/pkg/time"
	"github.com/goradd/goradd/web/examples/gen/goradd/model/node"
)

// projectBase is a base structure to be embedded in a "subclass" and provides the ORM access to the database.

type projectBase struct {
	id        string
	idIsValid bool
	idIsDirty bool

	num        int
	numIsValid bool
	numIsDirty bool

	statusTypeID        int
	statusTypeIDIsValid bool
	statusTypeIDIsDirty bool

	managerID        string
	managerIDIsNull  bool
	managerIDIsValid bool
	managerIDIsDirty bool
	oManager         *Person

	name        string
	nameIsValid bool
	nameIsDirty bool

	description        string
	descriptionIsNull  bool
	descriptionIsValid bool
	descriptionIsDirty bool

	startDate        time.Time
	startDateIsNull  bool
	startDateIsValid bool
	startDateIsDirty bool

	endDate        time.Time
	endDateIsNull  bool
	endDateIsValid bool
	endDateIsDirty bool

	budget        string
	budgetIsNull  bool
	budgetIsValid bool
	budgetIsDirty bool

	spent        string
	spentIsNull  bool
	spentIsValid bool
	spentIsDirty bool

	// Reverse reference objects.
	oMilestones        []*Milestone          // Objects in the order they were queried
	mMilestones        map[string]*Milestone // Objects by PK
	oMilestonesIsDirty bool

	// Many-Many reference objects.
	oChildrenAsParent        []*Project
	mChildrenAsParent        map[string]*Project // Objects by PK
	oChildrenAsParentIsDirty bool

	oParentsAsChild        []*Project
	mParentsAsChild        map[string]*Project // Objects by PK
	oParentsAsChildIsDirty bool

	oTeamMembers        []*Person
	mTeamMembers        map[string]*Person // Objects by PK
	oTeamMembersIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]interface{}

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update
	_restored bool

	// The original primary key for updates
	_originalPK string
}

const (
	ProjectIDDefault           = ""
	ProjectNumDefault          = 0
	ProjectStatusTypeIDDefault = 0
	ProjectManagerIDDefault    = ""
	ProjectNameDefault         = ""
	ProjectDescriptionDefault  = ""
	ProjectStartDateDefault    = time2.Zero
	ProjectEndDateDefault      = time2.Zero
	ProjectBudgetDefault       = ""
	ProjectSpentDefault        = ""
)

const (
	Project_ID = `ID`

	Project_Num = `Num`

	Project_StatusTypeID = `StatusTypeID`

	Project_ManagerID = `ManagerID`

	Project_Manager = `Manager`

	Project_Name = `Name`

	Project_Description = `Description`

	Project_StartDate = `StartDate`

	Project_EndDate = `EndDate`

	Project_Budget = `Budget`

	Project_Spent = `Spent`

	ProjectMilestones       = `Milestones`
	ProjectChildAsParent    = `ChildAsParent`
	ProjectChildrenAsParent = `ChildrenAsParent`
	ProjectParentAsChild    = `ParentAsChild`
	ProjectParentsAsChild   = `ParentsAsChild`
	ProjectTeamMember       = `TeamMember`
	ProjectTeamMembers      = `TeamMembers`
)

// Initialize or re-initialize a Project database object to default values.
func (o *projectBase) Initialize() {

	o.id = ""
	o.idIsValid = true
	o.idIsDirty = true

	o.num = 0
	o.numIsValid = false
	o.numIsDirty = false

	o.statusTypeID = 0
	o.statusTypeIDIsValid = false
	o.statusTypeIDIsDirty = false

	o.managerID = ""
	o.managerIDIsNull = true
	o.managerIDIsValid = true
	o.managerIDIsDirty = true

	o.name = ""
	o.nameIsValid = false
	o.nameIsDirty = false

	o.description = ""
	o.descriptionIsNull = true
	o.descriptionIsValid = true
	o.descriptionIsDirty = true

	o.startDate = time.Time{}
	o.startDateIsNull = true
	o.startDateIsValid = true
	o.startDateIsDirty = true

	o.endDate = time.Time{}
	o.endDateIsNull = true
	o.endDateIsValid = true
	o.endDateIsDirty = true

	o.budget = ""
	o.budgetIsNull = true
	o.budgetIsValid = true
	o.budgetIsDirty = true

	o.spent = ""
	o.spentIsNull = true
	o.spentIsValid = true
	o.spentIsDirty = true

	o._restored = false
}

// PrimaryKey returns the value of the primary key.
func (o *projectBase) PrimaryKey() string {
	return o.id
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object.
func (o *projectBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// ID returns the loaded value of ID.
func (o *projectBase) ID() string {
	return fmt.Sprint(o.id)
}

// IDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) IDIsValid() bool {
	return o._restored && o.idIsValid
}

// Num returns the loaded value of Num.
func (o *projectBase) Num() int {
	if o._restored && !o.numIsValid {
		panic("num was not selected in the last query and has not been set, and so is not valid")
	}
	return o.num
}

// NumIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NumIsValid() bool {
	return o.numIsValid
}

// SetNum sets the value of Num in the object, to be saved later using the Save() function.
func (o *projectBase) SetNum(v int) {
	o.numIsValid = true
	if o.num != v || !o._restored {
		o.num = v
		o.numIsDirty = true
	}

}

// ManagerID returns the loaded value of ManagerID.
func (o *projectBase) ManagerID() string {
	if o._restored && !o.managerIDIsValid {
		panic("managerID was not selected in the last query and has not been set, and so is not valid")
	}
	return o.managerID
}

// ManagerIDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) ManagerIDIsValid() bool {
	return o.managerIDIsValid
}

// ManagerIDIsNull returns true if the related database value is null.
func (o *projectBase) ManagerIDIsNull() bool {
	return o.managerIDIsNull
}

// ManagerID_I returns the loaded value of ManagerID as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) ManagerID_I() interface{} {
	if o._restored && !o.managerIDIsValid {
		panic("managerID was not selected in the last query and has not been set, and so is not valid")
	} else if o.managerIDIsNull {
		return nil
	}
	return o.managerID
}

// Manager returns the current value of the loaded Manager, and nil if its not loaded.
func (o *projectBase) Manager() *Person {
	return o.oManager
}

// LoadManager returns the related Manager. If it is not already loaded,
// it will attempt to load it first.
func (o *projectBase) LoadManager(ctx context.Context) *Person {
	if !o.managerIDIsValid {
		return nil
	}

	if o.oManager == nil {
		// Load and cache
		o.oManager = LoadPerson(ctx, o.ManagerID())
	}
	return o.oManager
}

func (o *projectBase) SetManagerID(i interface{}) {
	o.managerIDIsValid = true
	if i == nil {
		if !o.managerIDIsNull {
			o.managerIDIsNull = true
			o.managerIDIsDirty = true
			o.managerID = ""
			o.oManager = nil
		}
	} else {
		v := i.(string)
		if o.managerIDIsNull ||
			!o._restored ||
			o.managerID != v {

			o.managerIDIsNull = false
			o.managerID = v
			o.managerIDIsDirty = true
			o.oManager = nil
		}
	}
}

func (o *projectBase) SetManager(v *Person) {
	o.managerIDIsValid = true
	if v == nil {
		if !o.managerIDIsNull || !o._restored {
			o.managerIDIsNull = true
			o.managerIDIsDirty = true
			o.managerID = ""
			o.oManager = nil
		}
	} else {
		o.oManager = v
		if o.managerIDIsNull || !o._restored || o.managerID != v.PrimaryKey() {
			o.managerIDIsNull = false
			o.managerID = v.PrimaryKey()
			o.managerIDIsDirty = true
		}
	}
}

// Name returns the loaded value of Name.
func (o *projectBase) Name() string {
	if o._restored && !o.nameIsValid {
		panic("name was not selected in the last query and has not been set, and so is not valid")
	}
	return o.name
}

// NameIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NameIsValid() bool {
	return o.nameIsValid
}

// SetName sets the value of Name in the object, to be saved later using the Save() function.
func (o *projectBase) SetName(v string) {
	o.nameIsValid = true
	if o.name != v || !o._restored {
		o.name = v
		o.nameIsDirty = true
	}

}

// Description returns the loaded value of Description.
func (o *projectBase) Description() string {
	if o._restored && !o.descriptionIsValid {
		panic("description was not selected in the last query and has not been set, and so is not valid")
	}
	return o.description
}

// DescriptionIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) DescriptionIsValid() bool {
	return o.descriptionIsValid
}

// DescriptionIsNull returns true if the related database value is null.
func (o *projectBase) DescriptionIsNull() bool {
	return o.descriptionIsNull
}

// Description_I returns the loaded value of Description as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Description_I() interface{} {
	if o._restored && !o.descriptionIsValid {
		panic("description was not selected in the last query and has not been set, and so is not valid")
	} else if o.descriptionIsNull {
		return nil
	}
	return o.description
}

func (o *projectBase) SetDescription(i interface{}) {
	o.descriptionIsValid = true
	if i == nil {
		if !o.descriptionIsNull {
			o.descriptionIsNull = true
			o.descriptionIsDirty = true
			o.description = ""
		}
	} else {
		v := i.(string)
		if o.descriptionIsNull ||
			!o._restored ||
			o.description != v {

			o.descriptionIsNull = false
			o.description = v
			o.descriptionIsDirty = true
		}
	}
}

// StartDate returns the loaded value of StartDate.
func (o *projectBase) StartDate() time.Time {
	if o._restored && !o.startDateIsValid {
		panic("startDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.startDate
}

// StartDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) StartDateIsValid() bool {
	return o.startDateIsValid
}

// StartDateIsNull returns true if the related database value is null.
func (o *projectBase) StartDateIsNull() bool {
	return o.startDateIsNull
}

// StartDate_I returns the loaded value of StartDate as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) StartDate_I() interface{} {
	if o._restored && !o.startDateIsValid {
		panic("startDate was not selected in the last query and has not been set, and so is not valid")
	} else if o.startDateIsNull {
		return nil
	}
	return o.startDate
}

func (o *projectBase) SetStartDate(i interface{}) {
	o.startDateIsValid = true
	if i == nil {
		if !o.startDateIsNull {
			o.startDateIsNull = true
			o.startDateIsDirty = true
			o.startDate = time.Time{}
		}
	} else {
		v := i.(time.Time)
		if o.startDateIsNull ||
			!o._restored ||
			o.startDate != v {

			o.startDateIsNull = false
			o.startDate = v
			o.startDateIsDirty = true
		}
	}
}

// EndDate returns the loaded value of EndDate.
func (o *projectBase) EndDate() time.Time {
	if o._restored && !o.endDateIsValid {
		panic("endDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.endDate
}

// EndDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) EndDateIsValid() bool {
	return o.endDateIsValid
}

// EndDateIsNull returns true if the related database value is null.
func (o *projectBase) EndDateIsNull() bool {
	return o.endDateIsNull
}

// EndDate_I returns the loaded value of EndDate as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) EndDate_I() interface{} {
	if o._restored && !o.endDateIsValid {
		panic("endDate was not selected in the last query and has not been set, and so is not valid")
	} else if o.endDateIsNull {
		return nil
	}
	return o.endDate
}

func (o *projectBase) SetEndDate(i interface{}) {
	o.endDateIsValid = true
	if i == nil {
		if !o.endDateIsNull {
			o.endDateIsNull = true
			o.endDateIsDirty = true
			o.endDate = time.Time{}
		}
	} else {
		v := i.(time.Time)
		if o.endDateIsNull ||
			!o._restored ||
			o.endDate != v {

			o.endDateIsNull = false
			o.endDate = v
			o.endDateIsDirty = true
		}
	}
}

// Budget returns the loaded value of Budget.
func (o *projectBase) Budget() string {
	if o._restored && !o.budgetIsValid {
		panic("budget was not selected in the last query and has not been set, and so is not valid")
	}
	return o.budget
}

// BudgetIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) BudgetIsValid() bool {
	return o.budgetIsValid
}

// BudgetIsNull returns true if the related database value is null.
func (o *projectBase) BudgetIsNull() bool {
	return o.budgetIsNull
}

// Budget_I returns the loaded value of Budget as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Budget_I() interface{} {
	if o._restored && !o.budgetIsValid {
		panic("budget was not selected in the last query and has not been set, and so is not valid")
	} else if o.budgetIsNull {
		return nil
	}
	return o.budget
}

func (o *projectBase) SetBudget(i interface{}) {
	o.budgetIsValid = true
	if i == nil {
		if !o.budgetIsNull {
			o.budgetIsNull = true
			o.budgetIsDirty = true
			o.budget = ""
		}
	} else {
		v := i.(string)
		if o.budgetIsNull ||
			!o._restored ||
			o.budget != v {

			o.budgetIsNull = false
			o.budget = v
			o.budgetIsDirty = true
		}
	}
}

// Spent returns the loaded value of Spent.
func (o *projectBase) Spent() string {
	if o._restored && !o.spentIsValid {
		panic("spent was not selected in the last query and has not been set, and so is not valid")
	}
	return o.spent
}

// SpentIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) SpentIsValid() bool {
	return o.spentIsValid
}

// SpentIsNull returns true if the related database value is null.
func (o *projectBase) SpentIsNull() bool {
	return o.spentIsNull
}

// Spent_I returns the loaded value of Spent as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Spent_I() interface{} {
	if o._restored && !o.spentIsValid {
		panic("spent was not selected in the last query and has not been set, and so is not valid")
	} else if o.spentIsNull {
		return nil
	}
	return o.spent
}

func (o *projectBase) SetSpent(i interface{}) {
	o.spentIsValid = true
	if i == nil {
		if !o.spentIsNull {
			o.spentIsNull = true
			o.spentIsDirty = true
			o.spent = ""
		}
	} else {
		v := i.(string)
		if o.spentIsNull ||
			!o._restored ||
			o.spent != v {

			o.spentIsNull = false
			o.spent = v
			o.spentIsDirty = true
		}
	}
}

// GetAlias returns the alias for the given key.
func (o *projectBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
		return query.NewAliasValue([]byte{})
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *projectBase) IsNew() bool {
	return !o._restored
}

func (o *projectBase) StatusType() ProjectStatusType {
	if o._restored && !o.statusTypeIDIsValid {
		panic("statusTypeID was not selected in the last query and so is not valid")
	}
	return ProjectStatusType(o.statusTypeID)
}

func (o *projectBase) SetStatusType(v ProjectStatusType) {
	if o.statusTypeID != int(v) {
		o.statusTypeID = int(v)
		o.statusTypeIDIsDirty = true
		o.statusTypeIDIsValid = true
	}
}

// ChildAsParent returns a single Project object by primary key, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) ChildAsParent(pk string) *Project {
	if o.mChildrenAsParent == nil {
		return nil
	}
	return o.mChildrenAsParent[pk]
}

// ChildrenAsParent returns a slice of Project objects if loaded. If not loaded, will return nil.
func (o *projectBase) ChildrenAsParent() []*Project {
	return o.oChildrenAsParent
}

// SetChildrenAsParent sets the associated objects to the given slice of Project objects.
// It will disassociate from all previously associated objects after saving.
func (o *projectBase) SetChildrenAsParent(objs []*Project) {
	o.oChildrenAsParent = objs
	o.oChildrenAsParentIsDirty = true
}

// LoadChildrenAsParent loads the associated ChildAsParent objects.
func (o *projectBase) LoadChildrenAsParent(ctx context.Context) {
	o.oChildrenAsParent = QueryProjects(ctx).
		Where(op.Equal(node.Project().ParentsAsChild(), o.PrimaryKey())).
		Load()

	o.mChildrenAsParent = map[string]*Project{}
	for _, i := range o.oChildrenAsParent {
		o.mChildrenAsParent[i.PrimaryKey()] = i
	}
}

// ParentAsChild returns a single Project object by primary key, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) ParentAsChild(pk string) *Project {
	if o.mParentsAsChild == nil {
		return nil
	}
	return o.mParentsAsChild[pk]
}

// ParentsAsChild returns a slice of Project objects if loaded. If not loaded, will return nil.
func (o *projectBase) ParentsAsChild() []*Project {
	return o.oParentsAsChild
}

// SetParentsAsChild sets the associated objects to the given slice of Project objects.
// It will disassociate from all previously associated objects after saving.
func (o *projectBase) SetParentsAsChild(objs []*Project) {
	o.oParentsAsChild = objs
	o.oParentsAsChildIsDirty = true
}

// LoadParentsAsChild loads the associated ParentAsChild objects.
func (o *projectBase) LoadParentsAsChild(ctx context.Context) {
	o.oParentsAsChild = QueryProjects(ctx).
		Where(op.Equal(node.Project().ChildrenAsParent(), o.PrimaryKey())).
		Load()

	o.mParentsAsChild = map[string]*Project{}
	for _, i := range o.oParentsAsChild {
		o.mParentsAsChild[i.PrimaryKey()] = i
	}
}

// TeamMember returns a single Person object by primary key, if one was loaded
// otherwise, it will return nil.
func (o *projectBase) TeamMember(pk string) *Person {
	if o.mTeamMembers == nil {
		return nil
	}
	return o.mTeamMembers[pk]
}

// TeamMembers returns a slice of Person objects if loaded. If not loaded, will return nil.
func (o *projectBase) TeamMembers() []*Person {
	return o.oTeamMembers
}

// SetTeamMembers sets the associated objects to the given slice of Person objects.
// It will disassociate from all previously associated objects after saving.
func (o *projectBase) SetTeamMembers(objs []*Person) {
	o.oTeamMembers = objs
	o.oTeamMembersIsDirty = true
}

// LoadTeamMembers loads the associated TeamMember objects.
func (o *projectBase) LoadTeamMembers(ctx context.Context) {
	o.oTeamMembers = QueryPeople(ctx).
		Where(op.Equal(node.Person().ProjectsAsTeamMember(), o.PrimaryKey())).
		Load()

	o.mTeamMembers = map[string]*Person{}
	for _, i := range o.oTeamMembers {
		o.mTeamMembers[i.PrimaryKey()] = i
	}
}

// Milestone returns a single Milestone object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return Milestone objects that are not saved.
func (o *projectBase) Milestone(pk string) *Milestone {
	if o.mMilestones == nil {
		return nil
	}
	v, _ := o.mMilestones[pk]
	return v
}

// Milestones returns a slice of Milestone objects if loaded.
func (o *projectBase) Milestones() []*Milestone {
	if o.oMilestones == nil {
		return nil
	}
	return o.oMilestones
}

// LoadMilestones loads a new slice of Milestone objects and returns it.
func (o *projectBase) LoadMilestones(ctx context.Context, conditions ...interface{}) []*Milestone {
	for _, obj := range o.oMilestones {
		if obj.IsDirty() {
			panic("You cannot load over items that have changed but have not been saved.")
		}
	}

	qb := queryMilestones(ctx)
	cond := Equal(node.Milestone().ProjectID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = And(conditions...)
	}

	o.oMilestones = qb.Where(cond).Load()

	o.mMilestones = make(map[string]*Milestone)
	for _, obj := range o.oMilestones {
		pk := obj.ID()
		o.mMilestones[pk] = obj
	}

	return o.oMilestones
}

// CountMilestones returns the number of Milestone objects in the database connected to this object.
func (o *projectBase) CountMilestones(ctx context.Context) int {
	return int(QueryMilestones(ctx).
		Where(Equal(node.Milestone().ProjectID(), o.PrimaryKey())).
		Count(false))
}

// SetMilestones associates the given objects with the Project.
// WARNING! If it has items already associated with it that will not be associated after a save,
// those items will be DELETED since they cannot be null.
// If you did not use a join to query the items in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be changing items
// that are not currently attached to this Project.
func (o *projectBase) SetMilestones(objs []*Milestone) {
	for _, obj := range o.oMilestones {
		if obj.IsDirty() {
			panic("You cannot overwrite items that have changed but have not been saved.")
		}
	}

	o.oMilestones = objs
	o.mMilestones = make(map[string]*Milestone)
	for _, obj := range o.oMilestones {
		pk := obj.ID()
		if pk != "" {
			o.mMilestones[pk] = obj
		}
	}
	o.oMilestonesIsDirty = true
}

// LoadProject returns a Project from the database.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
func LoadProject(ctx context.Context, primaryKey string, joinOrSelectNodes ...query.NodeI) *Project {
	return queryProjects(ctx).Where(Equal(node.Project().ID(), primaryKey)).joinOrSelect(joinOrSelectNodes...).Get()
}

// HasProject returns true if a Project with the give key exists database.
func HasProject(ctx context.Context, primaryKey string) bool {
	q := queryProjects(ctx)
	q = q.Where(Equal(node.Project().ID(), primaryKey))
	return q.Count(false) == 1
}

// LoadProjectByNum queries for a single Project object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectByNum(ctx context.Context, num int, joinOrSelectNodes ...query.NodeI) *Project {
	q := queryProjects(ctx)
	q = q.Where(Equal(node.Project().Num(), num))
	return q.
		joinOrSelect(joinOrSelectNodes...).
		Get()
}

// HasProjectByNum returns true if the
// given unique index values exist in the database.
func HasProjectByNum(ctx context.Context, num int) bool {
	q := queryProjects(ctx)
	q = q.Where(Equal(node.Project().Num(), num))
	return q.Count(false) == 1
}

// The ProjectsBuilder uses the QueryBuilderI interface from the database to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, Count, or Delete
type ProjectsBuilder struct {
	builder query.QueryBuilderI
}

func newProjectBuilder(ctx context.Context) *ProjectsBuilder {
	b := &ProjectsBuilder{
		builder: db.GetDatabase("goradd").NewBuilder(ctx),
	}
	return b.Join(node.Project())
}

// Load terminates the query builder, performs the query, and returns a slice of Project objects. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice
func (b *ProjectsBuilder) Load() (projectSlice []*Project) {
	results := b.builder.Load()
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Project)
		o.load(item, o, nil, "")
		projectSlice = append(projectSlice, o)
	}
	return projectSlice
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice.
func (b *ProjectsBuilder) LoadI() (projectSlice []interface{}) {
	results := b.builder.Load()
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Project)
		o.load(item, o, nil, "")
		projectSlice = append(projectSlice, o)
	}
	return projectSlice
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *ProjectsBuilder) LoadCursor() projectCursor {
	cursor := b.builder.LoadCursor()

	return projectCursor{cursor}
}

type projectCursor struct {
	query.CursorI
}

// Next returns the current Project object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c projectCursor) Next() *Project {
	row := c.CursorI.Next()
	if row == nil {
		return nil
	}
	o := new(Project)
	o.load(row, o, nil, "")
	return o
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
func (b *ProjectsBuilder) Get() *Project {
	results := b.Load()
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *ProjectsBuilder) Expand(n query.NodeI) *ProjectsBuilder {
	b.builder.Expand(n)
	return b
}

// Join adds a node to the node tree so that its fields will appear in the query. Optionally add conditions to filter
// what gets included. The conditions will be AND'd with the basic condition matching the primary keys of the join.
func (b *ProjectsBuilder) Join(n query.NodeI, conditions ...query.NodeI) *ProjectsBuilder {
	var condition query.NodeI
	if len(conditions) > 1 {
		condition = And(conditions)
	} else if len(conditions) == 1 {
		condition = conditions[0]
	}
	b.builder.Join(n, condition)
	return b
}

// Where adds a condition to filter what gets selected.
func (b *ProjectsBuilder) Where(c query.NodeI) *ProjectsBuilder {
	b.builder.Condition(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
func (b *ProjectsBuilder) OrderBy(nodes ...query.NodeI) *ProjectsBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified
func (b *ProjectsBuilder) Limit(maxRowCount int, offset int) *ProjectsBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select optimizes the query to only return the specified fields. Once you put a Select in your query, you must
// specify all the fields that you will eventually read out. Be careful when selecting fields in joined tables, as joined
// tables will also contain pointers back to the parent table, and so the parent node should have the same field selected
// as the child node if you are querying those fields.
func (b *ProjectsBuilder) Select(nodes ...query.NodeI) *ProjectsBuilder {
	b.builder.Select(nodes...)
	return b
}

// Alias lets you add a node with a custom name. After the query, you can read out the data using GetAlias() on a
// returned object. Alias is useful for adding calculations or subqueries to the query.
func (b *ProjectsBuilder) Alias(name string, n query.NodeI) *ProjectsBuilder {
	b.builder.Alias(name, n)
	return b
}

// Distinct removes duplicates from the results of the query. Adding a Select() may help you get to the data you want, although
// using Distinct with joined tables is often not effective, since we force joined tables to include primary keys in the query, and this
// often ruins the effect of Distinct.
func (b *ProjectsBuilder) Distinct() *ProjectsBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions in an Alias() call.
func (b *ProjectsBuilder) GroupBy(nodes ...query.NodeI) *ProjectsBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query.
func (b *ProjectsBuilder) Having(node query.NodeI) *ProjectsBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items selected.
//
// distinct wll count the number of distinct items, ignoring duplicates.
//
// nodes will select individual fields, and should be accompanied by a GroupBy.
func (b *ProjectsBuilder) Count(distinct bool, nodes ...query.NodeI) uint {
	return b.builder.Count(distinct, nodes...)
}

// Delete uses the query builder to delete a group of records that match the criteria
func (b *ProjectsBuilder) Delete() {
	b.builder.Delete()
	broadcast.BulkChange(b.builder.Context(), "goradd", "public.project")
}

// Subquery uses the query builder to define a subquery within a larger query. You MUST include what
// you are selecting by adding Alias or Select functions on the subquery builder. Generally you would use
// this as a node to an Alias function on the surrounding query builder.
func (b *ProjectsBuilder) Subquery() *query.SubqueryNode {
	return b.builder.Subquery()
}

// joinOrSelect is a private helper function for the Load* functions
func (b *ProjectsBuilder) joinOrSelect(nodes ...query.NodeI) *ProjectsBuilder {
	for _, n := range nodes {
		switch n.(type) {
		case query.TableNodeI:
			b.builder.Join(n, nil)
		case *query.ColumnNode:
			b.Select(n)
		}
	}
	return b
}

func CountProjectByID(ctx context.Context, id string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().ID(), id)).Count(false)
}

func CountProjectByNum(ctx context.Context, num int) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Num(), num)).Count(false)
}

func CountProjectByStatusTypeID(ctx context.Context, statusTypeID int) uint {
	return queryProjects(ctx).Where(Equal(node.Project().StatusTypeID(), statusTypeID)).Count(false)
}

func CountProjectByManagerID(ctx context.Context, managerID string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().ManagerID(), managerID)).Count(false)
}

func CountProjectByName(ctx context.Context, name string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Name(), name)).Count(false)
}

func CountProjectByDescription(ctx context.Context, description string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Description(), description)).Count(false)
}

func CountProjectByStartDate(ctx context.Context, startDate time.Time) uint {
	return queryProjects(ctx).Where(Equal(node.Project().StartDate(), startDate)).Count(false)
}

func CountProjectByEndDate(ctx context.Context, endDate time.Time) uint {
	return queryProjects(ctx).Where(Equal(node.Project().EndDate(), endDate)).Count(false)
}

func CountProjectByBudget(ctx context.Context, budget string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Budget(), budget)).Count(false)
}

func CountProjectBySpent(ctx context.Context, spent string) uint {
	return queryProjects(ctx).Where(Equal(node.Project().Spent(), spent)).Count(false)
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
// Care must be taken in the query, as Select clauses might not be honored if the child object has fields selected which the parent object does not have.
func (o *projectBase) load(m map[string]interface{}, objThis *Project, objParent interface{}, parentKey string) {
	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsValid = true
			o.idIsDirty = false
			o._originalPK = o.id
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsValid = false
		o.id = ""
	}

	if v, ok := m["num"]; ok && v != nil {
		if o.num, ok = v.(int); ok {
			o.numIsValid = true
			o.numIsDirty = false
		} else {
			panic("Wrong type found for num.")
		}
	} else {
		o.numIsValid = false
		o.num = 0
	}

	if v, ok := m["status_type_id"]; ok && v != nil {
		if o.statusTypeID, ok = v.(int); ok {
			o.statusTypeIDIsValid = true
			o.statusTypeIDIsDirty = false
		} else {
			panic("Wrong type found for status_type_id.")
		}
	} else {
		o.statusTypeIDIsValid = false
		o.statusTypeID = 0
	}

	if v, ok := m["manager_id"]; ok {
		if v == nil {
			o.managerID = ""
			o.managerIDIsNull = true
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else if o.managerID, ok = v.(string); ok {
			o.managerIDIsNull = false
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for manager_id.")
		}
	} else {
		o.managerIDIsValid = false
		o.managerIDIsNull = true
		o.managerID = ""
	}
	if v, ok := m["Manager"]; ok {
		if oManager, ok2 := v.(map[string]interface{}); ok2 {
			o.oManager = new(Person)
			o.oManager.load(oManager, o.oManager, objThis, "ProjectsAsManager")
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for oManager object.")
		}
	} else {
		o.oManager = nil
	}

	if v, ok := m["name"]; ok && v != nil {
		if o.name, ok = v.(string); ok {
			o.nameIsValid = true
			o.nameIsDirty = false
		} else {
			panic("Wrong type found for name.")
		}
	} else {
		o.nameIsValid = false
		o.name = ""
	}

	if v, ok := m["description"]; ok {
		if v == nil {
			o.description = ""
			o.descriptionIsNull = true
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else if o.description, ok = v.(string); ok {
			o.descriptionIsNull = false
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else {
			panic("Wrong type found for description.")
		}
	} else {
		o.descriptionIsValid = false
		o.descriptionIsNull = true
		o.description = ""
	}
	if v, ok := m["start_date"]; ok {
		if v == nil {
			o.startDate = time.Time{}
			o.startDateIsNull = true
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else if o.startDate, ok = v.(time.Time); ok {
			o.startDateIsNull = false
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else {
			panic("Wrong type found for start_date.")
		}
	} else {
		o.startDateIsValid = false
		o.startDateIsNull = true
		o.startDate = time.Time{}
	}
	if v, ok := m["end_date"]; ok {
		if v == nil {
			o.endDate = time.Time{}
			o.endDateIsNull = true
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else if o.endDate, ok = v.(time.Time); ok {
			o.endDateIsNull = false
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else {
			panic("Wrong type found for end_date.")
		}
	} else {
		o.endDateIsValid = false
		o.endDateIsNull = true
		o.endDate = time.Time{}
	}
	if v, ok := m["budget"]; ok {
		if v == nil {
			o.budget = ""
			o.budgetIsNull = true
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else if o.budget, ok = v.(string); ok {
			o.budgetIsNull = false
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else {
			panic("Wrong type found for budget.")
		}
	} else {
		o.budgetIsValid = false
		o.budgetIsNull = true
		o.budget = ""
	}
	if v, ok := m["spent"]; ok {
		if v == nil {
			o.spent = ""
			o.spentIsNull = true
			o.spentIsValid = true
			o.spentIsDirty = false
		} else if o.spent, ok = v.(string); ok {
			o.spentIsNull = false
			o.spentIsValid = true
			o.spentIsDirty = false
		} else {
			panic("Wrong type found for spent.")
		}
	} else {
		o.spentIsValid = false
		o.spentIsNull = true
		o.spent = ""
	}
	if v, ok := m["ChildrenAsParent"]; ok {
		if oChildrenAsParent, ok2 := v.([]db.ValueMap); ok2 {
			o.oChildrenAsParent = []*Project{}
			o.mChildrenAsParent = map[string]*Project{}

			for _, v2 := range oChildrenAsParent {
				obj := new(Project)
				obj.load(v2, obj, objThis, "ParentsAsChild")
				o.oChildrenAsParent = append(o.oChildrenAsParent, obj)
				o.mChildrenAsParent[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oChildrenAsParent object.")
		}
	} else {
		o.oChildrenAsParent = nil
	}

	if v, ok := m["ParentsAsChild"]; ok {
		if oParentsAsChild, ok2 := v.([]db.ValueMap); ok2 {
			o.oParentsAsChild = []*Project{}
			o.mParentsAsChild = map[string]*Project{}

			for _, v2 := range oParentsAsChild {
				obj := new(Project)
				obj.load(v2, obj, objThis, "ChildrenAsParent")
				o.oParentsAsChild = append(o.oParentsAsChild, obj)
				o.mParentsAsChild[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oParentsAsChild object.")
		}
	} else {
		o.oParentsAsChild = nil
	}

	if v, ok := m["TeamMembers"]; ok {
		if oTeamMembers, ok2 := v.([]db.ValueMap); ok2 {
			o.oTeamMembers = []*Person{}
			o.mTeamMembers = map[string]*Person{}

			for _, v2 := range oTeamMembers {
				obj := new(Person)
				obj.load(v2, obj, objThis, "ProjectsAsTeamMember")
				o.oTeamMembers = append(o.oTeamMembers, obj)
				o.mTeamMembers[obj.PrimaryKey()] = obj
			}
		} else {
			panic("Wrong type found for oTeamMembers object.")
		}
	} else {
		o.oTeamMembers = nil
	}

	if v, ok := m["Milestones"]; ok {
		switch oMilestones := v.(type) {
		case []db.ValueMap:
			o.oMilestones = make([]*Milestone, 0, len(oMilestones))
			o.mMilestones = make(map[string]*Milestone, len(oMilestones))
			for _, v2 := range oMilestones {
				obj := new(Milestone)
				obj.load(v2, obj, objThis, "Project")
				o.oMilestones = append(o.oMilestones, obj)
				o.mMilestones[obj.PrimaryKey()] = obj
				o.oMilestonesIsDirty = false
			}
		case db.ValueMap: // single expansion
			obj := new(Milestone)
			obj.load(oMilestones, obj, objThis, "Project")
			o.oMilestones = []*Milestone{obj}
			o.oMilestonesIsDirty = false
		default:
			panic("Wrong type found for oMilestones object.")
		}
	} else {
		o.oMilestones = nil
		o.oMilestonesIsDirty = false
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}
	o._restored = true
}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *projectBase) Save(ctx context.Context) {
	if o._restored {
		o.update(ctx)
	} else {
		o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
func (o *projectBase) update(ctx context.Context) {
	var modifiedFields map[string]interface{}
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {

		if o.oManager != nil {
			o.oManager.Save(ctx)
			id := o.oManager.PrimaryKey()
			o.SetManagerID(id)
		}

		if !o._restored {
			panic("Cannot update a record that was not originally read from the database.")
		}

		modifiedFields = o.getModifiedFields()
		if len(modifiedFields) != 0 {
			d.Update(ctx, "public.project", modifiedFields, "id", o._originalPK)
		}

		if o.oMilestonesIsDirty {

			// Since the other side of the relationship cannot be null, the objects to be detached must be deleted
			// We take care to only delete objects that are not being reattached
			objs := QueryMilestones(ctx).
				Where(Equal(node.Milestone().ProjectID(), o.PrimaryKey())).
				Load()
			// TODO: select only the required fields
			for _, obj := range objs {
				if _, ok := o.mMilestones[obj.PrimaryKey()]; !ok {
					// The old object is not in the group of new objects
					obj.Delete(ctx)
				}
			}
			for _, obj := range o.oMilestones {
				obj.SetProjectID(o.PrimaryKey())
				obj.Save(ctx)
			}

		} else {

			for _, obj := range o.oMilestones {
				obj.Save(ctx)
			}

		}

		{
			var pks []string
			o.mChildrenAsParent = make(map[string]*Project)

			for _, obj := range o.oChildrenAsParent {
				obj.Save(ctx)
				o.mChildrenAsParent[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"related_project_assn",
					"parent_id",
					o.PrimaryKey(),
					"public.project",
					"child_id",
					pks)
			}
		}

		{
			var pks []string
			o.mParentsAsChild = make(map[string]*Project)

			for _, obj := range o.oParentsAsChild {
				obj.Save(ctx)
				o.mParentsAsChild[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"related_project_assn",
					"child_id",
					o.PrimaryKey(),
					"public.project",
					"parent_id",
					pks)
			}
		}

		{
			var pks []string
			o.mTeamMembers = make(map[string]*Person)

			for _, obj := range o.oTeamMembers {
				obj.Save(ctx)
				o.mTeamMembers[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"team_member_project_assn",
					"project_id",
					o.PrimaryKey(),
					"public.person",
					"team_member_id",
					pks)
			}
		}

	}) // transaction
	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd", "public.project", o._originalPK, stringmap.SortedKeys(modifiedFields)...)
	}
}

// insert will insert the item into the database. Related items will be saved.
func (o *projectBase) insert(ctx context.Context) {
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {
		if o.oManager != nil {
			o.oManager.Save(ctx)
			o.SetManager(o.oManager)
		}

		if !o.numIsValid {
			panic("a value for Num is required, and there is no default value. Call SetNum() before inserting the record.")
		}

		if !o.statusTypeIDIsValid {
			panic("a value for StatusTypeID is required, and there is no default value. Call SetStatusTypeID() before inserting the record.")
		}

		if !o.nameIsValid {
			panic("a value for Name is required, and there is no default value. Call SetName() before inserting the record.")
		}

		m := o.getValidFields()

		id := d.Insert(ctx, "public.project", m)
		o.id = id
		o._originalPK = id

		if o.oMilestones != nil {
			o.mMilestones = make(map[string]*Milestone)
			for _, obj := range o.oMilestones {
				obj.SetProjectID(id)
				obj.Save(ctx)
				o.mMilestones[obj.PrimaryKey()] = obj
			}
		}
		{
			var pks []string
			o.mChildrenAsParent = make(map[string]*Project)
			for _, obj := range o.oChildrenAsParent {
				obj.Save(ctx)
				o.mChildrenAsParent[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"related_project_assn",
					"parent_id",
					o.PrimaryKey(),
					"public.project",
					"child_id",
					pks)
			}
		}
		{
			var pks []string
			o.mParentsAsChild = make(map[string]*Project)
			for _, obj := range o.oParentsAsChild {
				obj.Save(ctx)
				o.mParentsAsChild[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"related_project_assn",
					"child_id",
					o.PrimaryKey(),
					"public.project",
					"parent_id",
					pks)
			}
		}
		{
			var pks []string
			o.mTeamMembers = make(map[string]*Person)
			for _, obj := range o.oTeamMembers {
				obj.Save(ctx)
				o.mTeamMembers[obj.PrimaryKey()] = obj
				pks = append(pks, obj.PrimaryKey())
			}
			if len(pks) != 0 {
				d.Associate(ctx,
					"team_member_project_assn",
					"project_id",
					o.PrimaryKey(),
					"public.person",
					"team_member_id",
					pks)
			}
		}

	}) // transaction
	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "public.project", o.PrimaryKey())
}

func (o *projectBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {

		fields["id"] = o.id

	}
	if o.numIsDirty {

		fields["num"] = o.num

	}
	if o.statusTypeIDIsDirty {

		fields["status_type_id"] = o.statusTypeID

	}
	if o.managerIDIsDirty {

		if o.managerIDIsNull {
			fields["manager_id"] = nil
		} else {
			fields["manager_id"] = o.managerID
		}

	}
	if o.nameIsDirty {

		fields["name"] = o.name

	}
	if o.descriptionIsDirty {

		if o.descriptionIsNull {
			fields["description"] = nil
		} else {
			fields["description"] = o.description
		}

	}
	if o.startDateIsDirty {

		if o.startDateIsNull {
			fields["start_date"] = nil
		} else {
			fields["start_date"] = o.startDate
		}

	}
	if o.endDateIsDirty {

		if o.endDateIsNull {
			fields["end_date"] = nil
		} else {
			fields["end_date"] = o.endDate
		}

	}
	if o.budgetIsDirty {

		if o.budgetIsNull {
			fields["budget"] = nil
		} else {
			fields["budget"] = o.budget
		}

	}
	if o.spentIsDirty {

		if o.spentIsNull {
			fields["spent"] = nil
		} else {
			fields["spent"] = o.spent
		}

	}
	return
}

func (o *projectBase) getValidFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.numIsValid {

		fields["num"] = o.num

	}
	if o.statusTypeIDIsValid {

		fields["status_type_id"] = o.statusTypeID

	}
	if o.managerIDIsValid {

		if o.managerIDIsNull {
			fields["manager_id"] = nil
		} else {
			fields["manager_id"] = o.managerID
		}

	}
	if o.nameIsValid {

		fields["name"] = o.name

	}
	if o.descriptionIsValid {

		if o.descriptionIsNull {
			fields["description"] = nil
		} else {
			fields["description"] = o.description
		}

	}
	if o.startDateIsValid {

		if o.startDateIsNull {
			fields["start_date"] = nil
		} else {
			fields["start_date"] = o.startDate
		}

	}
	if o.endDateIsValid {

		if o.endDateIsNull {
			fields["end_date"] = nil
		} else {
			fields["end_date"] = o.endDate
		}

	}
	if o.budgetIsValid {

		if o.budgetIsNull {
			fields["budget"] = nil
		} else {
			fields["budget"] = o.budget
		}

	}
	if o.spentIsValid {

		if o.spentIsNull {
			fields["spent"] = nil
		} else {
			fields["spent"] = o.spent
		}

	}
	return
}

// Delete deletes the associated record from the database.
func (o *projectBase) Delete(ctx context.Context) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {

		{
			c := QueryMilestones(ctx).
				Where(Equal(node.Milestone().ProjectID(), o.PrimaryKey())).
				Count(false)
			if c > 0 {
				panic("Cannot delete a record that has restricted foreign keys pointing to it.")
			}
		}

		d.Associate(ctx,
			"related_project_assn",
			"parent_id",
			o.PrimaryKey(),
			"public.project",
			"child_id",
			nil)

		d.Associate(ctx,
			"related_project_assn",
			"child_id",
			o.PrimaryKey(),
			"public.project",
			"parent_id",
			nil)

		d.Associate(ctx,
			"team_member_project_assn",
			"project_id",
			o.PrimaryKey(),
			"public.person",
			"team_member_id",
			nil)

		d.Delete(ctx, "public.project", "id", o.id)
	})
	broadcast.Delete(ctx, "goradd", "public.project", fmt.Sprint(o.id))
}

// deleteProject deletes the associated record from the database.
func deleteProject(ctx context.Context, pk string) {
	if obj := LoadProject(ctx, pk, node.Project().PrimaryKeyNode()); obj != nil {
		obj.Delete(ctx)
	}
}

func (o *projectBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.numIsDirty = false
	o.statusTypeIDIsDirty = false
	o.managerIDIsDirty = false
	o.nameIsDirty = false
	o.descriptionIsDirty = false
	o.startDateIsDirty = false
	o.endDateIsDirty = false
	o.budgetIsDirty = false
	o.spentIsDirty = false
	o.oMilestonesIsDirty = false

}

func (o *projectBase) IsDirty() bool {
	return o.idIsDirty ||
		o.numIsDirty ||
		o.statusTypeIDIsDirty ||
		o.managerIDIsDirty ||
		(o.oManager != nil && o.oManager.IsDirty()) ||
		o.nameIsDirty ||
		o.descriptionIsDirty ||
		o.startDateIsDirty ||
		o.endDateIsDirty ||
		o.budgetIsDirty ||
		o.spentIsDirty ||
		o.oMilestonesIsDirty

}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *projectBase) Get(key string) interface{} {

	switch key {
	case "ID":
		if !o.idIsValid {
			return nil
		}
		return o.id

	case "Num":
		if !o.numIsValid {
			return nil
		}
		return o.num

	case "StatusTypeID":
		if !o.statusTypeIDIsValid {
			return nil
		}
		return o.statusTypeID

	case "StatusType":
		return o.StatusType()

	case "ManagerID":
		if !o.managerIDIsValid {
			return nil
		}
		return o.managerID

	case "Manager":
		return o.Manager()

	case "Name":
		if !o.nameIsValid {
			return nil
		}
		return o.name

	case "Description":
		if !o.descriptionIsValid {
			return nil
		}
		return o.description

	case "StartDate":
		if !o.startDateIsValid {
			return nil
		}
		return o.startDate

	case "EndDate":
		if !o.endDateIsValid {
			return nil
		}
		return o.endDate

	case "Budget":
		if !o.budgetIsValid {
			return nil
		}
		return o.budget

	case "Spent":
		if !o.spentIsValid {
			return nil
		}
		return o.spent

	case "Milestones":
		return o.Milestones()

	case "ChildrenAsParent":
		return o.ChildrenAsParent()

	case "ParentsAsChild":
		return o.ParentsAsChild()

	case "TeamMembers":
		return o.TeamMembers()

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *projectBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err := encoder.Encode(o.id); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.num); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.numIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.numIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.statusTypeID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.statusTypeIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.statusTypeIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.managerID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.managerIDIsDirty); err != nil {
		return nil, err
	}

	if o.oManager == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.oManager); err != nil {
			return nil, err
		}
	}
	if err := encoder.Encode(o.name); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.description); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.descriptionIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.startDate); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.startDateIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.endDate); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.endDateIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.budget); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.budgetIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.spent); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.spentIsDirty); err != nil {
		return nil, err
	}

	if o.oMilestones == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.oMilestones); err != nil {
			return nil, err
		}
	}

	if o.oChildrenAsParent == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.oChildrenAsParent); err != nil {
			return nil, err
		}
	}
	if o.oParentsAsChild == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.oParentsAsChild); err != nil {
			return nil, err
		}
	}
	if o.oTeamMembers == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.oTeamMembers); err != nil {
			return nil, err
		}
	}

	if o._aliases == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o._aliases); err != nil {
			return nil, err
		}
	}

	if err := encoder.Encode(o._restored); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o._originalPK); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (o *projectBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)
	var isPtr bool

	_ = isPtr

	if err = dec.Decode(&o.id); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.num); err != nil {
		return
	}
	if err = dec.Decode(&o.numIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.numIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.statusTypeID); err != nil {
		return
	}
	if err = dec.Decode(&o.statusTypeIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.statusTypeIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.managerID); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.managerIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o.oManager); err != nil {
			return
		}
	}
	if err = dec.Decode(&o.name); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.description); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.descriptionIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.startDate); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.startDateIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.endDate); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.endDateIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.budget); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.budgetIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.spent); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.spentIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o.oMilestones); err != nil {
			return
		}
		if len(o.oMilestones) > 0 {
			o.mMilestones = make(map[string]*Milestone)
			for _, p := range o.oMilestones {
				o.mMilestones[p.PrimaryKey()] = p
			}
		}
	}

	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o.oChildrenAsParent); err != nil {
			return
		}
		if len(o.oChildrenAsParent) > 0 {
			o.mChildrenAsParent = make(map[string]*Project)

			for _, p := range o.oChildrenAsParent {
				o.mChildrenAsParent[p.PrimaryKey()] = p
			}
		}
	}
	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o.oParentsAsChild); err != nil {
			return
		}
		if len(o.oParentsAsChild) > 0 {
			o.mParentsAsChild = make(map[string]*Project)

			for _, p := range o.oParentsAsChild {
				o.mParentsAsChild[p.PrimaryKey()] = p
			}
		}
	}
	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o.oTeamMembers); err != nil {
			return
		}
		if len(o.oTeamMembers) > 0 {
			o.mTeamMembers = make(map[string]*Person)

			for _, p := range o.oTeamMembers {
				o.mTeamMembers[p.PrimaryKey()] = p
			}
		}
	}

	if err = dec.Decode(&isPtr); err != nil {
		return
	}
	if isPtr {
		if err = dec.Decode(&o._aliases); err != nil {
			return
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return
	}
	if err = dec.Decode(&o._originalPK); err != nil {
		return
	}

	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *projectBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *projectBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsValid {
		v["id"] = o.id
	}

	if o.numIsValid {
		v["num"] = o.num
	}

	if o.statusTypeIDIsValid {
		v["statusTypeID"] = o.statusTypeID
	}

	if o.statusTypeIDIsValid {
		v["statusType"] = o.StatusType().String()
	}
	if o.managerIDIsValid {
		if o.managerIDIsNull {
			v["managerID"] = nil
		} else {
			v["managerID"] = o.managerID
		}
	}

	if val := o.Manager(); val != nil {
		v["manager"] = val.MarshalStringMap()
	}
	if o.nameIsValid {
		v["name"] = o.name
	}

	if o.descriptionIsValid {
		if o.descriptionIsNull {
			v["description"] = nil
		} else {
			v["description"] = o.description
		}
	}

	if o.startDateIsValid {
		if o.startDateIsNull {
			v["startDate"] = nil
		} else {
			v["startDate"] = o.startDate
		}
	}

	if o.endDateIsValid {
		if o.endDateIsNull {
			v["endDate"] = nil
		} else {
			v["endDate"] = o.endDate
		}
	}

	if o.budgetIsValid {
		if o.budgetIsNull {
			v["budget"] = nil
		} else {
			v["budget"] = o.budget
		}
	}

	if o.spentIsValid {
		if o.spentIsNull {
			v["spent"] = nil
		} else {
			v["spent"] = o.spent
		}
	}

	if val := o.Milestones(); val != nil {
		var val2 []map[string]interface{}
		for _, v2 := range val {
			val2 = append(val2, v2.MarshalStringMap())
		}
		v["project"] = val2
	}

	if val := o.ChildrenAsParent(); val != nil {
		var val2 []map[string]interface{}
		for _, v2 := range val {
			val2 = append(val2, v2.MarshalStringMap())
		}
		v["childrenAsParent"] = val2
	}
	if val := o.ParentsAsChild(); val != nil {
		var val2 []map[string]interface{}
		for _, v2 := range val {
			val2 = append(val2, v2.MarshalStringMap())
		}
		v["parentsAsChild"] = val2
	}
	if val := o.TeamMembers(); val != nil {
		var val2 []map[string]interface{}
		for _, v2 := range val {
			val2 = append(val2, v2.MarshalStringMap())
		}
		v["teamMembers"] = val2
	}

	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the project. The project can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//   "id" - string

//   "num" - int

//   "statusTypeID" - int

//   "managerID" - string, nullable

//   "name" - string

//   "description" - string, nullable

//   "startDate" - time.Time, nullable

//   "endDate" - time.Time, nullable

//   "budget" - string, nullable

//   "spent" - string, nullable

func (o *projectBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if err = json.Unmarshal(data, &v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in project to modify the json before sending it here.
func (o *projectBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {
		case "num":
			{
				if v == nil {
					return fmt.Errorf("json field %s cannot be null", k)
				}
				if n, ok := v.(int); ok {
					o.SetNum(int(n))
				} else if n, ok := v.(float64); ok {
					o.SetNum(int(n))
				} else {
					return fmt.Errorf("json field %s must be a number", k)
				}
			}
		case "statusTypeID":
			{
				if v == nil {
					return fmt.Errorf("json field %s cannot be null", k)
				}
				if n, ok := v.(int); ok {
					o.SetStatusType(ProjectStatusType(n))
				} else if n, ok := v.(float64); ok {
					o.SetStatusType(ProjectStatusType(int(n)))
				} else {
					return fmt.Errorf("json field %s must be a number", k)
				}
			}
		case "statusType":
			if s, ok := v.(string); !ok {
				return fmt.Errorf("json field %s must be a string", k)
			} else {
				t := ProjectStatusTypeFromName(s)
				if int(t) == 0 {
					return fmt.Errorf("invalid value for field %s", k)
				}
				o.SetStatusType(t)
			}

		case "managerID":
			{
				if v == nil {
					o.SetManagerID(v)
					continue
				}
				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetManagerID(s)
				}
			}
		case "name":
			{
				if v == nil {
					return fmt.Errorf("json field %s cannot be null", k)
				}
				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetName(s)
				}
			}
		case "description":
			{
				if v == nil {
					o.SetDescription(v)
					continue
				}
				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetDescription(s)
				}
			}
		case "startDate":
			{
				if v == nil {
					o.SetStartDate(v)
					continue
				}
				switch d := v.(type) {
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetStartDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetStartDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}
		case "endDate":
			{
				if v == nil {
					o.SetEndDate(v)
					continue
				}
				switch d := v.(type) {
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetEndDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetEndDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}
		case "budget":
			{
				if v == nil {
					o.SetBudget(v)
					continue
				}
				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetBudget(s)
				}
			}
		case "spent":
			{
				if v == nil {
					o.SetSpent(v)
					continue
				}
				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetSpent(s)
				}
			}

		}
	}
	return
}

// Custom functions. See goradd/codegen/templates/orm/modelBase.
