package model

// Code generated by goradd. DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/goradd/goradd/pkg/orm/broadcast"
	"github.com/goradd/goradd/pkg/orm/db"
	. "github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/pkg/orm/query"
	"github.com/goradd/goradd/pkg/stringmap"
	"github.com/goradd/goradd/web/examples/gen/goraddUnit/model/node"

	//"./node"
	"bytes"
	"encoding/gob"
	"encoding/json"
)

// forwardBase is a base structure to be embedded in a "subclass" and provides the ORM access to the database.
// Do not directly access the internal variables, but rather use the accessor functions, since this class maintains internal state
// related to the variables.

type forwardBase struct {
	id        string
	idIsValid bool
	idIsDirty bool

	name        string
	nameIsValid bool
	nameIsDirty bool

	reverseNotNullID        string
	reverseNotNullIDIsValid bool
	reverseNotNullIDIsDirty bool
	oReverseNotNull         *Reverse

	reverseUniqueNotNullID        string
	reverseUniqueNotNullIDIsValid bool
	reverseUniqueNotNullIDIsDirty bool
	oReverseUniqueNotNull         *Reverse

	reverseNullID        string
	reverseNullIDIsNull  bool
	reverseNullIDIsValid bool
	reverseNullIDIsDirty bool
	oReverseNull         *Reverse

	reverseUniqueNullID        string
	reverseUniqueNullIDIsNull  bool
	reverseUniqueNullIDIsValid bool
	reverseUniqueNullIDIsDirty bool
	oReverseUniqueNull         *Reverse

	// Custom aliases, if specified
	_aliases map[string]interface{}

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update
	_restored bool
}

const (
	ForwardIDDefault                     = ""
	ForwardNameDefault                   = ""
	ForwardReverseNotNullIDDefault       = ""
	ForwardReverseUniqueNotNullIDDefault = ""
	ForwardReverseNullIDDefault          = ""
	ForwardReverseUniqueNullIDDefault    = ""
)

const (
	Forward_ID                     = `ID`
	Forward_Name                   = `Name`
	Forward_ReverseNotNullID       = `ReverseNotNullID`
	Forward_ReverseNotNull         = `ReverseNotNull`
	Forward_ReverseUniqueNotNullID = `ReverseUniqueNotNullID`
	Forward_ReverseUniqueNotNull   = `ReverseUniqueNotNull`
	Forward_ReverseNullID          = `ReverseNullID`
	Forward_ReverseNull            = `ReverseNull`
	Forward_ReverseUniqueNullID    = `ReverseUniqueNullID`
	Forward_ReverseUniqueNull      = `ReverseUniqueNull`
)

// Initialize or re-initialize a Forward database object to default values.
func (o *forwardBase) Initialize() {

	o.id = ""
	o.idIsValid = false
	o.idIsDirty = false

	o.name = ""
	o.nameIsValid = false
	o.nameIsDirty = false

	o.reverseNotNullID = ""
	o.reverseNotNullIDIsValid = false
	o.reverseNotNullIDIsDirty = false

	o.reverseUniqueNotNullID = ""
	o.reverseUniqueNotNullIDIsValid = false
	o.reverseUniqueNotNullIDIsDirty = false

	o.reverseNullID = ""
	o.reverseNullIDIsNull = true
	o.reverseNullIDIsValid = true
	o.reverseNullIDIsDirty = true

	o.reverseUniqueNullID = ""
	o.reverseUniqueNullIDIsNull = true
	o.reverseUniqueNullIDIsValid = true
	o.reverseUniqueNullIDIsDirty = true

	o._restored = false
}

func (o *forwardBase) PrimaryKey() string {
	return o.id
}

// ID returns the loaded value of ID.
func (o *forwardBase) ID() string {
	return fmt.Sprint(o.id)
}

// IDIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) IDIsValid() bool {
	return o._restored && o.idIsValid
}

func (o *forwardBase) Name() string {
	if o._restored && !o.nameIsValid {
		panic("name was not selected in the last query and so is not valid")
	}
	return o.name
}

// NameIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) NameIsValid() bool {
	return o.nameIsValid
}

// SetName sets the value of Name in the object, to be saved later using the Save() function.
func (o *forwardBase) SetName(v string) {
	o.nameIsValid = true
	if o.name != v || !o._restored {
		o.name = v
		o.nameIsDirty = true
	}

}

func (o *forwardBase) ReverseNotNullID() string {
	if o._restored && !o.reverseNotNullIDIsValid {
		panic("reverseNotNullID was not selected in the last query and so is not valid")
	}
	return o.reverseNotNullID
}

// ReverseNotNullIDIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) ReverseNotNullIDIsValid() bool {
	return o.reverseNotNullIDIsValid
}

// ReverseNotNull returns the current value of the loaded ReverseNotNull, and nil if its not loaded.
func (o *forwardBase) ReverseNotNull() *Reverse {
	return o.oReverseNotNull
}

// LoadReverseNotNull returns the related ReverseNotNull. If it is not already loaded,
// it will attempt to load it first.
func (o *forwardBase) LoadReverseNotNull(ctx context.Context) *Reverse {
	if !o.reverseNotNullIDIsValid {
		return nil
	}

	if o.oReverseNotNull == nil {
		// Load and cache
		o.oReverseNotNull = LoadReverse(ctx, o.ReverseNotNullID())
	}
	return o.oReverseNotNull
}

// SetReverseNotNullID sets the value of ReverseNotNullID in the object, to be saved later using the Save() function.
func (o *forwardBase) SetReverseNotNullID(v string) {
	o.reverseNotNullIDIsValid = true
	if o.reverseNotNullID != v || !o._restored {
		o.reverseNotNullID = v
		o.reverseNotNullIDIsDirty = true
		o.oReverseNotNull = nil
	}

}

// SetReverseNotNull sets the value of ReverseNotNull in the object, to be saved later using the Save() function.
func (o *forwardBase) SetReverseNotNull(v *Reverse) {
	if v == nil {
		panic("Cannot set ReverseNotNull to a null value.")
	} else {
		o.oReverseNotNull = v
		o.reverseNotNullIDIsValid = true
		if o.reverseNotNullID != v.PrimaryKey() {
			o.reverseNotNullID = v.PrimaryKey()
			o.reverseNotNullIDIsDirty = true
		}
	}
}

func (o *forwardBase) ReverseUniqueNotNullID() string {
	if o._restored && !o.reverseUniqueNotNullIDIsValid {
		panic("reverseUniqueNotNullID was not selected in the last query and so is not valid")
	}
	return o.reverseUniqueNotNullID
}

// ReverseUniqueNotNullIDIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) ReverseUniqueNotNullIDIsValid() bool {
	return o.reverseUniqueNotNullIDIsValid
}

// ReverseUniqueNotNull returns the current value of the loaded ReverseUniqueNotNull, and nil if its not loaded.
func (o *forwardBase) ReverseUniqueNotNull() *Reverse {
	return o.oReverseUniqueNotNull
}

// LoadReverseUniqueNotNull returns the related ReverseUniqueNotNull. If it is not already loaded,
// it will attempt to load it first.
func (o *forwardBase) LoadReverseUniqueNotNull(ctx context.Context) *Reverse {
	if !o.reverseUniqueNotNullIDIsValid {
		return nil
	}

	if o.oReverseUniqueNotNull == nil {
		// Load and cache
		o.oReverseUniqueNotNull = LoadReverse(ctx, o.ReverseUniqueNotNullID())
	}
	return o.oReverseUniqueNotNull
}

// SetReverseUniqueNotNullID sets the value of ReverseUniqueNotNullID in the object, to be saved later using the Save() function.
func (o *forwardBase) SetReverseUniqueNotNullID(v string) {
	o.reverseUniqueNotNullIDIsValid = true
	if o.reverseUniqueNotNullID != v || !o._restored {
		o.reverseUniqueNotNullID = v
		o.reverseUniqueNotNullIDIsDirty = true
		o.oReverseUniqueNotNull = nil
	}

}

// SetReverseUniqueNotNull sets the value of ReverseUniqueNotNull in the object, to be saved later using the Save() function.
func (o *forwardBase) SetReverseUniqueNotNull(v *Reverse) {
	if v == nil {
		panic("Cannot set ReverseUniqueNotNull to a null value.")
	} else {
		o.oReverseUniqueNotNull = v
		o.reverseUniqueNotNullIDIsValid = true
		if o.reverseUniqueNotNullID != v.PrimaryKey() {
			o.reverseUniqueNotNullID = v.PrimaryKey()
			o.reverseUniqueNotNullIDIsDirty = true
		}
	}
}

func (o *forwardBase) ReverseNullID() string {
	if o._restored && !o.reverseNullIDIsValid {
		panic("reverseNullID was not selected in the last query and so is not valid")
	}
	return o.reverseNullID
}

// ReverseNullIDIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) ReverseNullIDIsValid() bool {
	return o.reverseNullIDIsValid
}

// ReverseNullIDIsNull returns true if the related database value is null.
func (o *forwardBase) ReverseNullIDIsNull() bool {
	return o.reverseNullIDIsNull
}

// ReverseNull returns the current value of the loaded ReverseNull, and nil if its not loaded.
func (o *forwardBase) ReverseNull() *Reverse {
	return o.oReverseNull
}

// LoadReverseNull returns the related ReverseNull. If it is not already loaded,
// it will attempt to load it first.
func (o *forwardBase) LoadReverseNull(ctx context.Context) *Reverse {
	if !o.reverseNullIDIsValid {
		return nil
	}

	if o.oReverseNull == nil {
		// Load and cache
		o.oReverseNull = LoadReverse(ctx, o.ReverseNullID())
	}
	return o.oReverseNull
}

func (o *forwardBase) SetReverseNullID(i interface{}) {
	o.reverseNullIDIsValid = true
	if i == nil {
		if !o.reverseNullIDIsNull {
			o.reverseNullIDIsNull = true
			o.reverseNullIDIsDirty = true
			o.reverseNullID = ""
			o.oReverseNull = nil
		}
	} else {
		v := i.(string)
		if o.reverseNullIDIsNull ||
			!o._restored ||
			o.reverseNullID != v {

			o.reverseNullIDIsNull = false
			o.reverseNullID = v
			o.reverseNullIDIsDirty = true
			o.oReverseNull = nil
		}
	}
}

func (o *forwardBase) SetReverseNull(v *Reverse) {
	o.reverseNullIDIsValid = true
	if v == nil {
		if !o.reverseNullIDIsNull || !o._restored {
			o.reverseNullIDIsNull = true
			o.reverseNullIDIsDirty = true
			o.reverseNullID = ""
			o.oReverseNull = nil
		}
	} else {
		o.oReverseNull = v
		if o.reverseNullIDIsNull || !o._restored || o.reverseNullID != v.PrimaryKey() {
			o.reverseNullIDIsNull = false
			o.reverseNullID = v.PrimaryKey()
			o.reverseNullIDIsDirty = true
		}
	}
}

func (o *forwardBase) ReverseUniqueNullID() string {
	if o._restored && !o.reverseUniqueNullIDIsValid {
		panic("reverseUniqueNullID was not selected in the last query and so is not valid")
	}
	return o.reverseUniqueNullID
}

// ReverseUniqueNullIDIsValid returns true if the value was loaded from the database or has been set.
func (o *forwardBase) ReverseUniqueNullIDIsValid() bool {
	return o.reverseUniqueNullIDIsValid
}

// ReverseUniqueNullIDIsNull returns true if the related database value is null.
func (o *forwardBase) ReverseUniqueNullIDIsNull() bool {
	return o.reverseUniqueNullIDIsNull
}

// ReverseUniqueNull returns the current value of the loaded ReverseUniqueNull, and nil if its not loaded.
func (o *forwardBase) ReverseUniqueNull() *Reverse {
	return o.oReverseUniqueNull
}

// LoadReverseUniqueNull returns the related ReverseUniqueNull. If it is not already loaded,
// it will attempt to load it first.
func (o *forwardBase) LoadReverseUniqueNull(ctx context.Context) *Reverse {
	if !o.reverseUniqueNullIDIsValid {
		return nil
	}

	if o.oReverseUniqueNull == nil {
		// Load and cache
		o.oReverseUniqueNull = LoadReverse(ctx, o.ReverseUniqueNullID())
	}
	return o.oReverseUniqueNull
}

func (o *forwardBase) SetReverseUniqueNullID(i interface{}) {
	o.reverseUniqueNullIDIsValid = true
	if i == nil {
		if !o.reverseUniqueNullIDIsNull {
			o.reverseUniqueNullIDIsNull = true
			o.reverseUniqueNullIDIsDirty = true
			o.reverseUniqueNullID = ""
			o.oReverseUniqueNull = nil
		}
	} else {
		v := i.(string)
		if o.reverseUniqueNullIDIsNull ||
			!o._restored ||
			o.reverseUniqueNullID != v {

			o.reverseUniqueNullIDIsNull = false
			o.reverseUniqueNullID = v
			o.reverseUniqueNullIDIsDirty = true
			o.oReverseUniqueNull = nil
		}
	}
}

func (o *forwardBase) SetReverseUniqueNull(v *Reverse) {
	o.reverseUniqueNullIDIsValid = true
	if v == nil {
		if !o.reverseUniqueNullIDIsNull || !o._restored {
			o.reverseUniqueNullIDIsNull = true
			o.reverseUniqueNullIDIsDirty = true
			o.reverseUniqueNullID = ""
			o.oReverseUniqueNull = nil
		}
	} else {
		o.oReverseUniqueNull = v
		if o.reverseUniqueNullIDIsNull || !o._restored || o.reverseUniqueNullID != v.PrimaryKey() {
			o.reverseUniqueNullIDIsNull = false
			o.reverseUniqueNullID = v.PrimaryKey()
			o.reverseUniqueNullIDIsDirty = true
		}
	}
}

// GetAlias returns the alias for the given key.
func (o *forwardBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
		return query.NewAliasValue([]byte{})
	}
}

// Load returns a Forward from the database.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
func LoadForward(ctx context.Context, primaryKey string, joinOrSelectNodes ...query.NodeI) *Forward {
	return queryForwards(ctx).Where(Equal(node.Forward().ID(), primaryKey)).joinOrSelect(joinOrSelectNodes...).Get(ctx)
}

// LoadForwardByReverseUniqueNotNullID queries for a single Forward object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use QueryForwards() to start a query builder.
func LoadForwardByReverseUniqueNotNullID(ctx context.Context, reverse_unique_not_null_id string, joinOrSelectNodes ...query.NodeI) *Forward {
	return queryForwards(ctx).
		Where(Equal(node.Forward().ReverseUniqueNotNullID(), reverse_unique_not_null_id)).
		joinOrSelect(joinOrSelectNodes...).
		Get(ctx)
}

// LoadForwardByReverseUniqueNullID queries for a single Forward object by the given unique index values.
// joinOrSelectNodes lets you provide nodes for joining to other tables or selecting specific fields. Table nodes will
// be considered Join nodes, and column nodes will be Select nodes. See Join() and Select() for more info.
// If you need a more elaborate query, use QueryForwards() to start a query builder.
func LoadForwardByReverseUniqueNullID(ctx context.Context, reverse_unique_null_id string, joinOrSelectNodes ...query.NodeI) *Forward {
	return queryForwards(ctx).
		Where(Equal(node.Forward().ReverseUniqueNullID(), reverse_unique_null_id)).
		joinOrSelect(joinOrSelectNodes...).
		Get(ctx)
}

// The ForwardsBuilder uses the QueryBuilderI interface from the database to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, Count, or Delete
type ForwardsBuilder struct {
	base                query.QueryBuilderI
	hasConditionalJoins bool
}

func newForwardBuilder() *ForwardsBuilder {
	b := &ForwardsBuilder{
		base: db.GetDatabase("goraddUnit").
			NewBuilder(),
	}
	return b.Join(node.Forward())
}

// Load terminates the query builder, performs the query, and returns a slice of Forward objects. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice
func (b *ForwardsBuilder) Load(ctx context.Context) (forwardSlice []*Forward) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Forward)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		forwardSlice = append(forwardSlice, o)
	}
	return forwardSlice
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces. If there are
// any errors, they are returned in the context object. If no results come back from the query, it will return
// an empty slice.
func (b *ForwardsBuilder) LoadI(ctx context.Context) (forwardSlice []interface{}) {
	results := b.base.Load(ctx)
	if results == nil {
		return
	}
	for _, item := range results {
		o := new(Forward)
		o.load(item, !b.hasConditionalJoins, o, nil, "")
		forwardSlice = append(forwardSlice, o)
	}
	return forwardSlice
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
func (b *ForwardsBuilder) Get(ctx context.Context) *Forward {
	results := b.Load(ctx)
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *ForwardsBuilder) Expand(n query.NodeI) *ForwardsBuilder {
	b.base.Expand(n)
	return b
}

// Join adds a node to the node tree so that its fields will appear in the query. Optionally add conditions to filter
// what gets included. The conditions will be AND'd with the basic condition matching the primary keys of the join.
func (b *ForwardsBuilder) Join(n query.NodeI, conditions ...query.NodeI) *ForwardsBuilder {
	var condition query.NodeI
	if len(conditions) > 1 {
		condition = And(conditions)
	} else if len(conditions) == 1 {
		condition = conditions[0]
	}
	b.base.Join(n, condition)
	if condition != nil {
		b.hasConditionalJoins = true
	}
	return b
}

// Where adds a condition to filter what gets selected.
func (b *ForwardsBuilder) Where(c query.NodeI) *ForwardsBuilder {
	b.base.Condition(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
func (b *ForwardsBuilder) OrderBy(nodes ...query.NodeI) *ForwardsBuilder {
	b.base.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified
func (b *ForwardsBuilder) Limit(maxRowCount int, offset int) *ForwardsBuilder {
	b.base.Limit(maxRowCount, offset)
	return b
}

// Select optimizes the query to only return the specified fields. Once you put a Select in your query, you must
// specify all the fields that you will eventually read out. Be careful when selecting fields in joined tables, as joined
// tables will also contain pointers back to the parent table, and so the parent node should have the same field selected
// as the child node if you are querying those fields.
func (b *ForwardsBuilder) Select(nodes ...query.NodeI) *ForwardsBuilder {
	b.base.Select(nodes...)
	return b
}

// Alias lets you add a node with a custom name. After the query, you can read out the data using GetAlias() on a
// returned object. Alias is useful for adding calculations or subqueries to the query.
func (b *ForwardsBuilder) Alias(name string, n query.NodeI) *ForwardsBuilder {
	b.base.Alias(name, n)
	return b
}

// Distinct removes duplicates from the results of the query. Adding a Select() may help you get to the data you want, although
// using Distinct with joined tables is often not effective, since we force joined tables to include primary keys in the query, and this
// often ruins the effect of Distinct.
func (b *ForwardsBuilder) Distinct() *ForwardsBuilder {
	b.base.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions in an Alias() call.
func (b *ForwardsBuilder) GroupBy(nodes ...query.NodeI) *ForwardsBuilder {
	b.base.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query.
func (b *ForwardsBuilder) Having(node query.NodeI) *ForwardsBuilder {
	b.base.Having(node)
	return b
}

// Count terminates a query and returns just the number of items selected.
func (b *ForwardsBuilder) Count(ctx context.Context, distinct bool, nodes ...query.NodeI) uint {
	return b.base.Count(ctx, distinct, nodes...)
}

// Delete uses the query builder to delete a group of records that match the criteria
func (b *ForwardsBuilder) Delete(ctx context.Context) {
	b.base.Delete(ctx)
}

// Subquery uses the query builder to define a subquery within a larger query. You MUST include what
// you are selecting by adding Alias or Select functions on the subquery builder. Generally you would use
// this as a node to an Alias function on the surrounding query builder.
func (b *ForwardsBuilder) Subquery() *query.SubqueryNode {
	return b.base.Subquery()
}

// joinOrSelect is a private helper function for the Load* functions
func (b *ForwardsBuilder) joinOrSelect(nodes ...query.NodeI) *ForwardsBuilder {
	for _, n := range nodes {
		switch n.(type) {
		case query.TableNodeI:
			b.base.Join(n, nil)
		case *query.ColumnNode:
			b.Select(n)
		}
	}
	return b
}

func CountForwardByID(ctx context.Context, id string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().ID(), id)).Count(ctx, false)
}

func CountForwardByName(ctx context.Context, name string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().Name(), name)).Count(ctx, false)
}

func CountForwardByReverseNotNullID(ctx context.Context, reverseNotNullID string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().ReverseNotNullID(), reverseNotNullID)).Count(ctx, false)
}

func CountForwardByReverseUniqueNotNullID(ctx context.Context, reverseUniqueNotNullID string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().ReverseUniqueNotNullID(), reverseUniqueNotNullID)).Count(ctx, false)
}

func CountForwardByReverseNullID(ctx context.Context, reverseNullID string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().ReverseNullID(), reverseNullID)).Count(ctx, false)
}

func CountForwardByReverseUniqueNullID(ctx context.Context, reverseUniqueNullID string) uint {
	return queryForwards(ctx).Where(Equal(node.Forward().ReverseUniqueNullID(), reverseUniqueNullID)).Count(ctx, false)
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
// If linkParent is true we will have child relationships use a pointer back to the parent object. If false, it will create a separate object.
// Care must be taken in the query, as Select clauses might not be honored if the child object has fields selected which the parent object does not have.
// Also, if any joins are conditional, that might affect which child objects are included, so in this situation, linkParent should be false
func (o *forwardBase) load(m map[string]interface{}, linkParent bool, objThis *Forward, objParent interface{}, parentKey string) {
	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsValid = true
			o.idIsDirty = false
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsValid = false
		o.id = ""
	}

	if v, ok := m["name"]; ok && v != nil {
		if o.name, ok = v.(string); ok {
			o.nameIsValid = true
			o.nameIsDirty = false
		} else {
			panic("Wrong type found for name.")
		}
	} else {
		o.nameIsValid = false
		o.name = ""
	}

	if v, ok := m["reverse_not_null_id"]; ok && v != nil {
		if o.reverseNotNullID, ok = v.(string); ok {
			o.reverseNotNullIDIsValid = true
			o.reverseNotNullIDIsDirty = false
		} else {
			panic("Wrong type found for reverse_not_null_id.")
		}
	} else {
		o.reverseNotNullIDIsValid = false
		o.reverseNotNullID = ""
	}

	if linkParent && parentKey == "ReverseNotNull" {
		o.oReverseNotNull = objParent.(*Reverse)
		o.reverseNotNullIDIsValid = true
		o.reverseNotNullIDIsDirty = false
	} else if v, ok := m["ReverseNotNull"]; ok {
		if oReverseNotNull, ok2 := v.(map[string]interface{}); ok2 {
			o.oReverseNotNull = new(Reverse)
			o.oReverseNotNull.load(oReverseNotNull, linkParent, o.oReverseNotNull, objThis, "ForwardsAsNotNull")
			o.reverseNotNullIDIsValid = true
			o.reverseNotNullIDIsDirty = false
		} else {
			panic("Wrong type found for oReverseNotNull object.")
		}
	} else {
		o.oReverseNotNull = nil
	}

	if v, ok := m["reverse_unique_not_null_id"]; ok && v != nil {
		if o.reverseUniqueNotNullID, ok = v.(string); ok {
			o.reverseUniqueNotNullIDIsValid = true
			o.reverseUniqueNotNullIDIsDirty = false
		} else {
			panic("Wrong type found for reverse_unique_not_null_id.")
		}
	} else {
		o.reverseUniqueNotNullIDIsValid = false
		o.reverseUniqueNotNullID = ""
	}

	if linkParent && parentKey == "ReverseUniqueNotNull" {
		o.oReverseUniqueNotNull = objParent.(*Reverse)
		o.reverseUniqueNotNullIDIsValid = true
		o.reverseUniqueNotNullIDIsDirty = false
	} else if v, ok := m["ReverseUniqueNotNull"]; ok {
		if oReverseUniqueNotNull, ok2 := v.(map[string]interface{}); ok2 {
			o.oReverseUniqueNotNull = new(Reverse)
			o.oReverseUniqueNotNull.load(oReverseUniqueNotNull, linkParent, o.oReverseUniqueNotNull, objThis, "ForwardsAsUniqueNotNull")
			o.reverseUniqueNotNullIDIsValid = true
			o.reverseUniqueNotNullIDIsDirty = false
		} else {
			panic("Wrong type found for oReverseUniqueNotNull object.")
		}
	} else {
		o.oReverseUniqueNotNull = nil
	}

	if v, ok := m["reverse_null_id"]; ok {
		if v == nil {
			o.reverseNullID = ""
			o.reverseNullIDIsNull = true
			o.reverseNullIDIsValid = true
			o.reverseNullIDIsDirty = false
		} else if o.reverseNullID, ok = v.(string); ok {
			o.reverseNullIDIsNull = false
			o.reverseNullIDIsValid = true
			o.reverseNullIDIsDirty = false
		} else {
			panic("Wrong type found for reverse_null_id.")
		}
	} else {
		o.reverseNullIDIsValid = false
		o.reverseNullIDIsNull = true
		o.reverseNullID = ""
	}
	if linkParent && parentKey == "ReverseNull" {
		o.oReverseNull = objParent.(*Reverse)
		o.reverseNullIDIsValid = true
		o.reverseNullIDIsDirty = false
	} else if v, ok := m["ReverseNull"]; ok {
		if oReverseNull, ok2 := v.(map[string]interface{}); ok2 {
			o.oReverseNull = new(Reverse)
			o.oReverseNull.load(oReverseNull, linkParent, o.oReverseNull, objThis, "ForwardsAsNull")
			o.reverseNullIDIsValid = true
			o.reverseNullIDIsDirty = false
		} else {
			panic("Wrong type found for oReverseNull object.")
		}
	} else {
		o.oReverseNull = nil
	}

	if v, ok := m["reverse_unique_null_id"]; ok {
		if v == nil {
			o.reverseUniqueNullID = ""
			o.reverseUniqueNullIDIsNull = true
			o.reverseUniqueNullIDIsValid = true
			o.reverseUniqueNullIDIsDirty = false
		} else if o.reverseUniqueNullID, ok = v.(string); ok {
			o.reverseUniqueNullIDIsNull = false
			o.reverseUniqueNullIDIsValid = true
			o.reverseUniqueNullIDIsDirty = false
		} else {
			panic("Wrong type found for reverse_unique_null_id.")
		}
	} else {
		o.reverseUniqueNullIDIsValid = false
		o.reverseUniqueNullIDIsNull = true
		o.reverseUniqueNullID = ""
	}
	if linkParent && parentKey == "ReverseUniqueNull" {
		o.oReverseUniqueNull = objParent.(*Reverse)
		o.reverseUniqueNullIDIsValid = true
		o.reverseUniqueNullIDIsDirty = false
	} else if v, ok := m["ReverseUniqueNull"]; ok {
		if oReverseUniqueNull, ok2 := v.(map[string]interface{}); ok2 {
			o.oReverseUniqueNull = new(Reverse)
			o.oReverseUniqueNull.load(oReverseUniqueNull, linkParent, o.oReverseUniqueNull, objThis, "ForwardsAsUniqueNull")
			o.reverseUniqueNullIDIsValid = true
			o.reverseUniqueNullIDIsDirty = false
		} else {
			panic("Wrong type found for oReverseUniqueNull object.")
		}
	} else {
		o.oReverseUniqueNull = nil
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}
	o._restored = true
}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *forwardBase) Save(ctx context.Context) {
	if o._restored {
		o.Update(ctx)
	} else {
		o.Insert(ctx)
	}
}

// Update will update the values in the database, saving any changed values.
func (o *forwardBase) Update(ctx context.Context) {
	if o.oReverseNotNull != nil {
		o.oReverseNotNull.Save(ctx)
		id := o.oReverseNotNull.PrimaryKey()
		o.SetReverseNotNullID(id)
	}
	if o.oReverseUniqueNotNull != nil {
		o.oReverseUniqueNotNull.Save(ctx)
		id := o.oReverseUniqueNotNull.PrimaryKey()
		o.SetReverseUniqueNotNullID(id)
	}
	if o.oReverseNull != nil {
		o.oReverseNull.Save(ctx)
		id := o.oReverseNull.PrimaryKey()
		o.SetReverseNullID(id)
	}
	if o.oReverseUniqueNull != nil {
		o.oReverseUniqueNull.Save(ctx)
		id := o.oReverseUniqueNull.PrimaryKey()
		o.SetReverseUniqueNullID(id)
	}

	if !o._restored {
		panic("Cannot update a record that was not originally read from the database.")
	}
	m := o.getModifiedFields()
	if len(m) == 0 {
		return
	}
	d := db.GetDatabase("goraddUnit")
	txid := d.Begin(ctx)
	defer d.Rollback(ctx, txid)
	d.Update(ctx, "forward", m, "id", fmt.Sprint(o.id))

	d.Commit(ctx, txid)
	o.resetDirtyStatus()
	broadcast.Update(ctx, "goraddUnit", "forward", fmt.Sprint(o.id), stringmap.SortedKeys(m)...)
}

// Insert forces the object to be inserted into the database. If the object was loaded from the database originally,
// this will create a duplicate in the database.
func (o *forwardBase) Insert(ctx context.Context) {
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {
		if o.oReverseNotNull != nil {
			o.oReverseNotNull.Save(ctx)
			id := o.oReverseNotNull.PrimaryKey()
			o.SetReverseNotNullID(id)
		}
		if o.oReverseUniqueNotNull != nil {
			o.oReverseUniqueNotNull.Save(ctx)
			id := o.oReverseUniqueNotNull.PrimaryKey()
			o.SetReverseUniqueNotNullID(id)
		}
		if o.oReverseNull != nil {
			o.oReverseNull.Save(ctx)
			id := o.oReverseNull.PrimaryKey()
			o.SetReverseNullID(id)
		}
		if o.oReverseUniqueNull != nil {
			o.oReverseUniqueNull.Save(ctx)
			id := o.oReverseUniqueNull.PrimaryKey()
			o.SetReverseUniqueNullID(id)
		}

		m := o.getModifiedFields()
		if len(m) == 0 {
			return
		}

		id := d.Insert(ctx, "forward", m)
		o.id = id
	}) // transaction
	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goraddUnit", "forward", fmt.Sprint(o.id))
}

func (o *forwardBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}

	if o.nameIsDirty {
		fields["name"] = o.name
	}

	if o.reverseNotNullIDIsDirty {
		fields["reverse_not_null_id"] = o.reverseNotNullID
	}

	if o.reverseUniqueNotNullIDIsDirty {
		fields["reverse_unique_not_null_id"] = o.reverseUniqueNotNullID
	}

	if o.reverseNullIDIsDirty {
		if o.reverseNullIDIsNull {
			fields["reverse_null_id"] = nil
		} else {
			fields["reverse_null_id"] = o.reverseNullID
		}
	}

	if o.reverseUniqueNullIDIsDirty {
		if o.reverseUniqueNullIDIsNull {
			fields["reverse_unique_null_id"] = nil
		} else {
			fields["reverse_unique_null_id"] = o.reverseUniqueNullID
		}
	}

	return
}

// Delete deletes the associated record from the database.
func (o *forwardBase) Delete(ctx context.Context) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := db.GetDatabase("goraddUnit")
	d.Delete(ctx, "forward", "id", o.id)
	broadcast.Delete(ctx, "goraddUnit", "forward", fmt.Sprint(o.id))
}

// deleteForward deletes the associated record from the database.
func deleteForward(ctx context.Context, pk string) {
	d := db.GetDatabase("goraddUnit")
	d.Delete(ctx, "forward", "id", pk)
	broadcast.Delete(ctx, "goraddUnit", "forward", pk)
}

func (o *forwardBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.nameIsDirty = false
	o.reverseNotNullIDIsDirty = false
	o.reverseUniqueNotNullIDIsDirty = false
	o.reverseNullIDIsDirty = false
	o.reverseUniqueNullIDIsDirty = false

}

func (o *forwardBase) IsDirty() bool {
	return o.idIsDirty ||
		o.nameIsDirty ||
		o.reverseNotNullIDIsDirty || (o.oReverseNotNull != nil && o.oReverseNotNull.IsDirty()) ||
		o.reverseUniqueNotNullIDIsDirty || (o.oReverseUniqueNotNull != nil && o.oReverseUniqueNotNull.IsDirty()) ||
		o.reverseNullIDIsDirty || (o.oReverseNull != nil && o.oReverseNull.IsDirty()) ||
		o.reverseUniqueNullIDIsDirty || (o.oReverseUniqueNull != nil && o.oReverseUniqueNull.IsDirty())
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *forwardBase) Get(key string) interface{} {

	switch key {
	case "ID":
		if !o.idIsValid {
			return nil
		}
		return o.id

	case "Name":
		if !o.nameIsValid {
			return nil
		}
		return o.name

	case "ReverseNotNullID":
		if !o.reverseNotNullIDIsValid {
			return nil
		}
		return o.reverseNotNullID

	case "ReverseNotNull":
		return o.ReverseNotNull()

	case "ReverseUniqueNotNullID":
		if !o.reverseUniqueNotNullIDIsValid {
			return nil
		}
		return o.reverseUniqueNotNullID

	case "ReverseUniqueNotNull":
		return o.ReverseUniqueNotNull()

	case "ReverseNullID":
		if !o.reverseNullIDIsValid {
			return nil
		}
		return o.reverseNullID

	case "ReverseNull":
		return o.ReverseNull()

	case "ReverseUniqueNullID":
		if !o.reverseUniqueNullIDIsValid {
			return nil
		}
		return o.reverseUniqueNullID

	case "ReverseUniqueNull":
		return o.ReverseUniqueNull()

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database object over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *forwardBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err := encoder.Encode(o.id); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.idIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.name); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.nameIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.reverseNotNullID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNotNullIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNotNullIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oReverseNotNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNotNullID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNotNullIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNotNullIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oReverseUniqueNotNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNullID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNullIDIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNullIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseNullIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oReverseNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNullID); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNullIDIsNull); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNullIDIsValid); err != nil {
		return nil, err
	}
	if err := encoder.Encode(o.reverseUniqueNullIDIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.oReverseUniqueNull); err != nil {
		return nil, err
	}

	if o._aliases == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o._aliases); err != nil {
			return nil, err
		}
	}

	if err := encoder.Encode(o._restored); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (o *forwardBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)

	if err = dec.Decode(&o.id); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.name); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.nameIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.reverseNotNullID); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNotNullIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNotNullIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oReverseNotNull); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNotNullID); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNotNullIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNotNullIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oReverseUniqueNotNull); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNullID); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNullIDIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNullIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseNullIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oReverseNull); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNullID); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNullIDIsNull); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNullIDIsValid); err != nil {
		return
	}
	if err = dec.Decode(&o.reverseUniqueNullIDIsDirty); err != nil {
		return
	}

	if err = dec.Decode(&o.oReverseUniqueNull); err != nil {
		return
	}

	var hasAliases bool
	if err = dec.Decode(&hasAliases); err != nil {
		return
	}
	if hasAliases {
		if err = dec.Decode(&o._aliases); err != nil {
			return
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return
	}

	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object.
func (o *forwardBase) MarshalJSON() (data []byte, err error) {
	v := make(map[string]interface{})

	if o.idIsValid {
		v["id"] = o.id
	}

	if o.nameIsValid {
		v["name"] = o.name
	}

	if o.reverseNotNullIDIsValid {
		v["reverseNotNullID"] = o.reverseNotNullID
	}

	if val := o.ReverseNotNull(); val != nil {
		v["reverseNotNull"] = val
	}
	if o.reverseUniqueNotNullIDIsValid {
		v["reverseUniqueNotNullID"] = o.reverseUniqueNotNullID
	}

	if val := o.ReverseUniqueNotNull(); val != nil {
		v["reverseUniqueNotNull"] = val
	}
	if o.reverseNullIDIsValid {
		if o.reverseNullIDIsNull {
			v["reverseNullID"] = nil
		} else {
			v["reverseNullID"] = o.reverseNullID
		}
	}

	if val := o.ReverseNull(); val != nil {
		v["reverseNull"] = val
	}
	if o.reverseUniqueNullIDIsValid {
		if o.reverseUniqueNullIDIsNull {
			v["reverseUniqueNullID"] = nil
		} else {
			v["reverseUniqueNullID"] = o.reverseUniqueNullID
		}
	}

	if val := o.ReverseUniqueNull(); val != nil {
		v["reverseUniqueNull"] = val
	}

	return json.Marshal(v)
}
