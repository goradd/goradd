//** This file was code generated by GoT. DO NOT EDIT. ***

package orm

import (
	"context"
	"io"

	"github.com/goradd/goradd/pkg/orm/op"
	"github.com/goradd/goradd/web/examples/gen/goradd/model"
	"github.com/goradd/goradd/web/examples/gen/goradd/model/node"
)

func (ctrl *QueryPanel) DrawTemplate(ctx context.Context, _w io.Writer) (err error) {

	if _, err = io.WriteString(_w, `<h1>Using a QueryBuilder and Nodes</h1>

<p>In the previous example, you saw how to load a single object using model.Load* functions.
 In this example you will learn how to query for an array of objects using a <strong>QueryBuilder</strong>.</p>

<p>Begin a query using a call to model.Query* functions. For example, if you want to return Person objects,
you would make a call to model.QueryPeople(). If you stop there, you will be selecting all of the People in the
Person database.</p>

<h3>All People</h3>
<p>
`); err != nil {
		return
	}

	for _, person := range model.QueryPeople(ctx).Load() {

		if _, err = io.WriteString(_w, `<div>`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.FirstName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.LastName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `</div>
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `</p>
<h2>Refining Queries with Statements and Nodes</h2>
<p>You can further refine your query by adding the following functions to the QueryBuilder returned by the Query* functions.
A brief description is given below, and further examples for some of them can be found in later pages.
</p>
<table>
<tr><td>Where</td><td>Where adds conditions to the query to filter the query. Multiple conditions will be
ANDed together.</td></tr>
<tr><td>OrderBy</td><td>OrderBy defines the fields that will be used to sort the resulting array slice.
Multiple fields can be specified, and you can sort in descending order by adding the Descending() function
to the specified field.</td></tr>
<tr><td>Limit</td><td>Limits the resulting values to a maximum number of values. You can also specify
which of the total selection will be the first one. You can use this to page through a big result set.</td></tr>
<tr><td>GroupBy</td><td>GroupBy reduces the result set to select only one of each distinct value in
the specified fields. This can be combined with an "Alias" mentioned below.
<tr><td>Alias</td><td>Alias creates a custom named value in each of the resulting slices. You can use this
to specify the result of a calculation. Certain grouping operations, like Sum, Count, or Max, can be combined with
a GroupBy function to calculate values for each group.</td></tr>
<tr><td>Join</td><td>Join will add a linked object to the query, one that is linked through a relationship
defined in the database. Join statements can be given a condition to restrict which linked objects are attached to
each returned main object.</td></tr>
<tr><td>Select</td><td>Normally all the fields in an object are returned, and you can use whichever ones
you want. If you would like to optimize your query so that only certain fields are returned from the database,
you can specify which fields to return in the Select function.</td></tr>
<tr><td>Expand</td><td>Normally when joining objects in a one-to-many or many-to-many relationship, an
array of objects are attached to each main object. In certain situations, you might want to instead have
multiple main objects be returned, with one of each of the sub-objects attached. You do this using the
Expand statement.</td></tr>
<tr><td>Distinct</td><td>Distinct will remove duplicates of the result set. It is similar to GroupBy, but you
cannot specify operations to perform in each group. </td></tr>
<tr><td>Having</td><td>"Where" conditions filter out items from the results using just the fields in the table.
"Having" is an additional filter that operates on the results after any calculations
are performed, which "Where" cannot do since "Where" filters before calculations are done. In other words, "Where"
controls which values are sent into calculations, and "Having" controls which items are shown based on the
results of the calculations.</td></tr>
</table>
<p>
Once your QueryBuilder is ready to execute, you have some options on what to do with the QueryBuilder:
</p>
<table>
<tr><td>Load</td><td>Load will run the query and return a slice of objects.</td></tr>
<tr><td>LoadI</td><td>Load will run the query and return a slice of interfaces.</td></tr>
<tr><td>Get</td><td>Get will return only one object, whatever object comes up first in the query.</td></tr>
<tr><td>Count</td><td>Count will return the number of records that would result from the query.</td></tr>
<tr><td>Delete</td><td>Delete deletes the selected records.</td></tr>
</table>

<p>
<div>People With Last Name of Smith</div>
`); err != nil {
		return
	}

	for _, person := range model.QueryPeople(ctx).
		Where(op.Equal(node.Person().LastName(), "Smith")).
		Load() {

		if _, err = io.WriteString(_w, `<div>`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.FirstName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.LastName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `</div>
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `</p>
<p>
<div>People in Last/First order</div>
`); err != nil {
		return
	}

	for _, person := range model.QueryPeople(ctx).
		OrderBy(node.Person().LastName(), node.Person().FirstName()).
		Load() {

		if _, err = io.WriteString(_w, `<div>`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.FirstName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, person.LastName()); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `</div>
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `</p>


`); err != nil {
		return
	}

	return
}
