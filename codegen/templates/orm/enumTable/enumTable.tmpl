
propName := tt.GoName
propPlural := tt.GoPlural
propLetter := strings.ToLower(propName[0:1])
keyField := tt.FieldNames[0]

{{
// Code generated by GoRADD. DO NOT EDIT.

package model

import (
	//"log"
	//"github.com/goradd/goradd/pkg/orm/query"
	"strconv"
)

const (
}}
for _,value := range tt.Values {
	key,_ := value[keyField].(int)
	con := tt.Constants[key]
{{
	{{= propName }}{{= con }} {{= propName }} = {{u key }}
}}
}

{{
)

// {{= propName }}MaxValue is the maximum enumerated value of {{= propName }}
// doc: type={{= propName }}
const {{= propName }}MaxValue = {{i len(tt.Values) }}

type {{= propName }} int

// String returns the name value of the type and satisfies the fmt.Stringer interface
func ({{= propLetter }} {{= propName }}) String() string {
	switch {{= propLetter }} {
	case 0: return ""
{{for _,value := range tt.Values }}
	case {{= generator.AsConstant(value[keyField], query.ColTypeInteger) }}: return {{= generator.AsConstant(value[tt.FieldNames[1]], query.ColTypeString) }}
{{for}}
	default: panic("index out of range")
	}
	return "" // prevent warning
}

// ID returns a string representation of the id and satisfies the IDer interface
func ({{= propLetter }} {{= propName }}) ID() string {
	return strconv.Itoa(int({{= propLetter }}))
}

// {{= propName }}FromID converts a {{= propName }} ID to a {{= propName }}
func {{= propName }}FromID (id string) {{= propName }} {
	switch id {
{{for _,value := range tt.Values }}
	case "{{= generator.AsConstant(value[keyField], query.ColTypeInteger) }}": return {{= propName }}({{= generator.AsConstant(value[keyField], query.ColTypeInteger) }})
{{for}}
	}
	return {{= propName }}(0)
}

// {{= propPlural }}FromIDs converts a slice of {{= propName }} IDs to a slice of {{= propName }}
func {{= propPlural }}FromIDs (ids []string) (values []{{= propName }}) {
    values = make([]{{= propName }}, 0, len(ids))
    for _,id := range ids {
        values = append(values, {{= propName }}FromID(id))
    }
    return
}

// {{= propName }}FromName converts a {{= propName }} name to a {{= propName }}
func {{= propName }}FromName (name string) {{= propName }} {
	switch name {
{{for _,value := range tt.Values }}
	case {{= generator.AsConstant(value[tt.FieldNames[1]], query.ColTypeString) }}: return {{= propName }}({{= generator.AsConstant(value[keyField], query.ColTypeInteger) }})
{{for}}
	}
	return {{= propName }}(0)
}


// All{{= propPlural }} returns a slice of all the {{= propName }} values.
func All{{= propPlural }}() (values []{{= propName }}) {
{{for _,value := range tt.Values }}
    values = append(values, {{= generator.AsConstant(value[keyField], query.ColTypeInteger) }})
{{for}}
    return
}

// All{{= propPlural }}I returns a slice of all the {{= propName }} values as generic interfaces.
// doc: type={{= propName }}
func All{{= propPlural }}I() (values []any) {
    values = make([]interface{}, {{i len(tt.Values) }}, {{i len(tt.Values) }})
{{for i,value := range tt.Values }}
    values[{{i i }}] = {{= propName }}({{= generator.AsConstant(value[keyField], query.ColTypeInteger) }})
{{for}}
    return
}

// Label returns the string that will be displayed to a user for this item. Together with
// the Value function, it satisfies the ItemLister interface that makes it easy
// to create a dropdown list of items.
func ({{= propLetter }} {{= propName }}) Label() string {
	return {{= propLetter }}.String()
}

// Value returns the value that will be used in dropdown lists and satisfies the
// Valuer and ItemLister interfaces.
func ({{= propLetter }} {{= propName }}) Value() interface{} {
	return {{= propLetter }}.ID()
}


}}

for i := range tt.FieldNames[1:] {
	typ := tt.FieldGoColumnType(i+1)
	typeName := typ.GoType()
	title := tt.FieldGoName(i+1)

{{
func ({{= propLetter }} {{= propName }}) {{= title }}() {{= typeName }} {
	switch {{= propLetter }} {
	case 0: return {{= typ.DefaultValue() }}
{{g for _,value := range tt.Values { }}
	case {{= generator.AsConstant(value[keyField], query.ColTypeInteger) }}: return {{= generator.AsConstant(value[tt.FieldNames[i+1]], typ) }}
{{g } }}
	default: panic("Index out of range")
	}
	return {{= typ.DefaultValue() }} // prevent warning
}

}}

}


for i,fieldName := range tt.FieldNames[1:] {
	typ := tt.FieldGoColumnType(i+1)
	typeName := typ.GoType()
	title := tt.FieldGoPlural(i+1)

{{
// {{= propName }}{{= title }} returns a slice of all the {{= title }} associated with {{= propName }} values.
// doc: type={{= propName }}
func {{= propName }}{{= title }}() []{{= typeName }} {
	return []{{= typeName }} {
	    // 0 item will be a blank
	    {{= typ.DefaultValue() }},
{{g for _,value := range tt.Values { }}
	    {{= generator.AsConstant(value[fieldName], typ) }},
{{g } }}
    }
}

}}

}

{{
func ({{= propLetter }} {{= propName }}) Get(key string) interface{} {

    switch(key) {
}}

for _,fieldName := range tt.FieldNames[1:] {
	title := db.UpperCaseIdentifier(fieldName)

{{
    case "{{= title }}": return {{= propLetter }}.{{= title }}()
}}

}

{{
    default: return nil
    }
}
}}