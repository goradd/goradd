package column

import (
	"context"
	"github.com/goradd/goradd/pkg/orm/query"
	"github.com/goradd/goradd/pkg/page"
	"github.com/goradd/goradd/pkg/page/control"
	"reflect"
)

// NodeColumn is a column that uses a query.NodeI to get its text out of data that is coming from the ORM.
// Create it with NewNodeColumn
type NodeColumn struct {
	control.ColumnBase
	node query.NodeI
}

// NewNodeColumn creates a table column that uses a query.NodeI object to get its text out of an ORM object.
// node should point to data that is preloaded in the ORM object. If the node points to a Date, Time or DateTime type
// of column, you MUST specify a time format by calling SetTimeFormat.
func NewNodeColumn(node query.NodeI) *NodeColumn {
	i := NodeColumn{}
	i.Init(node)
	i.node = node
	return &i
}

func (c *NodeColumn) Init(node query.NodeI) {
	if node == nil {
		panic("node is required")
	}
	c.ColumnBase.Init(c)
	c.SetTitle(query.NodeGoName(node))
}

func (c *NodeColumn) GetNode() query.NodeI {
	return c.node
}

func (c *NodeColumn) CellData(ctx context.Context, rowNum int, colNum int, data interface{}) interface{} {
	if v, ok := data.(Getter); !ok {
		return ""
	} else {
		n := c.node
		var names []string

		// walk up the chain of nodes to figure out how to walk down the chain of data
		for {
			name := query.NodeGoName(n)
			if name == "" {
				break
			}
			names = append(names, name)
			n = query.ParentNode(n)
			if n == nil {
				break
			}
		}
		if len(names) < 2 {
			panic("bad node passed to the column_node column. These nodes must start with a table node and end with a column node")
		}
		var i int
		v2 := v
		for i = len(names) - 2; i > 0; i-- {
			obj := v2.Get(names[i])
			if obj == nil || reflect.ValueOf(obj).IsNil() {
				panic("database object has not loaded the items referred to in the node. Make sure you are joining the correct tables")
			}
			v2, ok = obj.(Getter)
			if !ok {
				panic("node chain does not match a chain of Getters (forward, reverse and manyMany references")
			}
		}
		s := v2.Get(names[0]) // This should be a column node
		return s
	}
}

func (c *NodeColumn) Serialize(e page.Encoder) (err error) {
	if err = c.ColumnBase.Serialize(e); err != nil {
		return
	}
	if err = e.Encode(c.node); err != nil {
		return
	}
	return
}

func (c *NodeColumn) Deserialize(dec page.Decoder) (err error) {
	if err = c.ColumnBase.Deserialize(dec); err != nil {
		panic(err)
	}
	if err = dec.Decode(&c.node); err != nil {
		panic(err)
	}
	return
}



type NodeGetter interface {
	GetNode() query.NodeI
}

// MakeNodeSlice is a convenience method to convert a slice of columns into a slice of nodes derived from
// those columns. The column slice would typically come from the table's SortColumns method, and the returned
// slice would be passed to the database's OrderBy clause when building a query. Since this is a common use, it
// will also add sort info to the nodes.
func MakeNodeSlice(columns []control.ColumnI) []query.NodeI {
	var nodes []query.NodeI
	for _, c := range columns {
		if getter, ok := c.(NodeGetter); ok {
			node := getter.GetNode()
			if nodeSorter, ok := node.(query.NodeSorter); ok {
				switch c.SortDirection() {
				case control.SortAscending:
					nodeSorter.Ascending()
				case control.SortDescending:
					nodeSorter.Descending()
				}
			}
			nodes = append(nodes, node)
		} else {
			panic("Column is not a NodeGetter.")
		}
	}
	return nodes
}

// NodeColumnCreator creates a column that treats each row as data from the ORM, and gets to that data using
// a database Node.
type NodeColumnCreator struct {
	// ID will assign the given id to the column. If you do not specify it, an id will be given it by the framework.
	ID string
	// Node is a database node generated by the code generator
	Node query.NodeI
	// Title is the title of the column that will appear in the header
	Title string
	// Sortable makes the column display sort arrows in the header
	Sortable bool
	control.ColumnOptions
}

func (c NodeColumnCreator) Create(ctx context.Context, parent control.TableI) control.ColumnI {
	col := NewNodeColumn(c.Node)
	if c.ID != "" {
		col.SetID(c.ID)
	}
	col.SetTitle(c.Title)
	if c.Sortable {
		col.SetSortable()
	}
	col.ApplyOptions(ctx, parent, c.ColumnOptions)
	return col
}

func init() {
	control.RegisterColumn(NodeColumn{})
}