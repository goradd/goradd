package db

import (
	"fmt"
	"github.com/goradd/goradd/pkg/datetime"
	. "github.com/goradd/goradd/pkg/orm/query"
	"strings"
)

// Column describes a database column. Most of the information is either
// gleaned from the structure of the database, or is taken from a file that describes the relationships between
// different record types. Some of the information is filled in after analysis. Some of the information can be
// provided through information embedded in database comments.
type Column struct {
	// DbName is the name of the column in the database. This is blank if this is a "virtual" table for sql tables like an association or virtual attribute query.
	DbName string
	// GoName is the name of the column in go code
	GoName string
	// NativeType is the type of the column as described by the database itself.
	NativeType string
	//  ColumnType is the goradd defined column type
	ColumnType GoColumnType
	// MaxCharLength is the maximum length of characters to allow in the column if a string type column.
	// If the database has the ability to specify this, this will correspond to what is specified.
	// In any case, we will generate code to prevent fields from getting bigger than this.
	MaxCharLength uint64
	// DefaultValue is the default value as specified by the database. We will initialize new ORM objects
	// with this value. It will be case to the corresponding GO type.
	DefaultValue interface{}
	// MaxValue is the maximum value allowed for numeric values. This can be used by UI objects to tell the user what the limits are.
	MaxValue interface{}
	// MinValue is the minimum value allowed for numeric values. This can be used by UI objects to tell the user what the limits are.
	MinValue interface{}
	// IsId is true if this column represents a unique identifier generated by the database
	IsId bool
	// IsPk is true if this is the primary key column. PK's do not necessarily need to be ID columns, and if not, we will need to do our own work to generate unique PKs.
	IsPk bool
	// IsNullable is true if the column can be given a NULL value
	IsNullable bool
	// IsUnique is true if the column's table has a single unique index on the column.
	IsUnique bool
	// IsTimestamp is true if the field is a timestamp. Timestamps represent a specific point in world time.
	IsTimestamp bool
	// IsAutoUpdateTimestamp is true if the database is updating the timestamp. Otherwise we will do it manually.
	IsAutoUpdateTimestamp bool
	// IsDateOnly indicates that we have a datetime type of column that should only be concerned about the date
	IsDateOnly bool
	// IsTimeOnly indicates that we have a datetime type of column that should only be concerned about the time
	IsTimeOnly bool
	// Comment is the contents of the comment associated with this field
	Comment string

	// Filled in by analyzer
	// Options are the options extracted from the comments string
	Options map[string]interface{}
	// ForeignKey is additional information describing a foreign key relationship
	ForeignKey *ForeignKeyInfo
	// ModelName is a cache for the internal model name of this column.
	ModelName string
}

// DefaultConstantName returns the name of the default value constant that will be used to refer to the default value
func (cd *Column) DefaultConstantName(tableName string) string {
	title := tableName + cd.GoName + "Default"
	return title
}

// DefaultValueAsValue returns the default value of the column as a GO value
func (cd *Column) DefaultValueAsValue() string {
	if cd.DefaultValue == nil {
		v := cd.ColumnType.DefaultValue()
		if v == "" {
			return "nil"
		} else {
			return v
		}
	} else if cd.ColumnType == ColTypeDateTime {
		if b, _ := cd.DefaultValue.(datetime.DateTime).MarshalText(); b == nil {
			return cd.ColumnType.DefaultValue()
		} else {
			s := string(b[:])
			if cd.IsTimestamp {
				return fmt.Sprintf("datetime.NewTimestamp(%#v)", s)
			} else {
				return fmt.Sprintf("datetime.NewDateTime(%#v)", s)
			}
		}

	} else {
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

// DefaultValueAsConstant returns the default value of the column as a GO constant
func (cd *Column) DefaultValueAsConstant() string {
	if cd.ColumnType == ColTypeDateTime {
		if cd.DefaultValue == nil {
			return "datetime.Zero" // pass this to datetime.NewDateTime()
		} else {
			d := cd.DefaultValue.(datetime.DateTime)
			if b, _ := d.MarshalText(); b == nil {
				return "datetime.Zero"
			} else {
				s := string(b[:])
				return fmt.Sprintf("%#v", s)
			}
		}
	} else if cd.DefaultValue == nil {
		return cd.ColumnType.DefaultValue()
	} else {
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

func (cd *Column) JsonKey() string {
	return cd.ModelName
}

// IsReference returns true if the column is a foreign key pointing to another table
func (cd *Column) IsReference() bool {
	return cd.ForeignKey != nil
}

// ReferenceFunction returns the function name that should be used to refer to the object
// that is referred to by a forward reference. It is extracted from the name of foreign key.
func (cd *Column) ReferenceFunction(dd *Database) string {
	if cd.IsReference() {
		if cd.ForeignKey.IsType {
			suf := UpperCaseIdentifier(dd.ForeignKeySuffix)
			goName := strings.TrimSuffix(cd.GoName, suf)
			return goName
		} else {
			return cd.ForeignKey.GoName
		}
	}
	return ""
}

// ReferenceJsonKey returns the key that will be used for the referenced object in JSON.
func (cd *Column) ReferenceJsonKey(dd *Database) string {
	return LowerCaseIdentifier(strings.TrimSuffix(cd.DbName, dd.ForeignKeySuffix))
}
